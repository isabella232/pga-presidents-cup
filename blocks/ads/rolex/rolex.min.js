/* eslint-disable */
/* Modernizr 2.5.3 (Custom Build) | MIT & BSD
 * Build: http://www.modernizr.com/download/#-canvas-svg-svgclippaths-cssclasses-addtest
 */
window.Modernizr = (function (e, t, n) {
  function r(e) { d.cssText = e; }

  function i(e, t) { return r(prefixes.join(`${e};`) + (t || '')); }

  function s(e, t) { return typeof e === t; }

  function o(e, t) { return !!~(`${e}`).indexOf(t); }

  function u(e, t, r) { for (const i in e) { const o = t[e[i]]; if (o !== n) return r === !1 ? e[i] : s(o, 'function') ? o.bind(r || t) : o; } return !1; } const a = '2.5.3';
  const f = {};
  const l = !0;
  const c = t.documentElement;
  const h = 'modernizr';
  let p = t.createElement(h);
  var d = p.style;
  let v;
  const m = {}.toString;
  const g = { svg: 'http://www.w3.org/2000/svg' };
  const y = {};
  const b = {};
  const w = {};
  const E = [];
  const S = E.slice;
  let x;
  const T = {}.hasOwnProperty;
  let N; !s(T, 'undefined') && !s(T.call, 'undefined') ? N = function (e, t) { return T.call(e, t); } : N = function (e, t) { return t in e && s(e.constructor.prototype[t], 'undefined'); }, Function.prototype.bind || (Function.prototype.bind = function (e) {
    const t = this; if (typeof t !== 'function') throw new TypeError(); const n = S.call(arguments, 1);
    var r = function () {
      if (this instanceof r) {
        const i = function () {};
        i.prototype = t.prototype; const s = new i();
        const o = t.apply(s, n.concat(S.call(arguments))); return Object(o) === o ? o : s;
      } return t.apply(e, n.concat(S.call(arguments)));
    }; return r;
  }), y.canvas = function () { const e = t.createElement('canvas'); return !!e.getContext && !!e.getContext('2d'); }, y.svg = function () { return !!t.createElementNS && !!t.createElementNS(g.svg, 'svg').createSVGRect; }, y.svgclippaths = function () { return !!t.createElementNS && /SVGClipPath/.test(m.call(t.createElementNS(g.svg, 'clipPath'))); }; for (const C in y) N(y, C) && (x = C.toLowerCase(), f[x] = y[C](), E.push((f[x] ? '' : 'no-') + x)); return f.addTest = function (e, t) {
    if (typeof e === 'object') for (const r in e) N(e, r) && f.addTest(r, e[r]);
    else {
      e = e.toLowerCase(); if (f[e] !== n) return f;
      t = typeof t === 'function' ? t() : t, c.className += ` ${t ? '' : 'no-'}${e}`, f[e] = t;
    } return f;
  }, r(''), p = v = null, f._version = a, c.className = c.className.replace(/(^|\s)no-js(\s|$)/, '$1$2') + (l ? ` js ${E.join(' ')}` : ''), f;
}(this, this.document));
Modernizr.addTest('retina', () => window.devicePixelRatio >= 2);
/*! jQuery v3.3.1 | (c) JS Foundation and other contributors | jquery.org/license */
!(function (e, t) {
  typeof module === 'object' && typeof module.exports === 'object' ? module.exports = e.document ? t(e, !0) : function (e) { if (!e.document) throw new Error('jQuery requires a window with a document'); return t(e); } : t(e);
}(typeof window !== 'undefined' ? window : this, (e, t) => {
  const n = [];
  const r = e.document;
  const i = Object.getPrototypeOf;
  const o = n.slice;
  const a = n.concat;
  const s = n.push;
  const u = n.indexOf;
  const l = {};
  const c = l.toString;
  const f = l.hasOwnProperty;
  const p = f.toString;
  const d = p.call(Object);
  const h = {};
  const g = function e(t) { return typeof t === 'function' && typeof t.nodeType !== 'number'; };
  const y = function e(t) { return t != null && t === t.window; };
  const v = { type: !0, src: !0, noModule: !0 };

  function m(e, t, n) {
    let i; const
      o = (t = t || r).createElement('script'); if (o.text = e, n) for (i in v) n[i] && (o[i] = n[i]);
    t.head.appendChild(o).parentNode.removeChild(o);
  }

  function x(e) { return e == null ? `${e}` : typeof e === 'object' || typeof e === 'function' ? l[c.call(e)] || 'object' : typeof e; } const b = '3.3.1';
  var w = function (e, t) { return new w.fn.init(e, t); };
  const T = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  w.fn = w.prototype = {
    jquery: '3.3.1',
    constructor: w,
    length: 0,
    toArray() { return o.call(this); },
    get(e) { return e == null ? o.call(this) : e < 0 ? this[e + this.length] : this[e]; },
    pushStack(e) { const t = w.merge(this.constructor(), e); return t.prevObject = this, t; },
    each(e) { return w.each(this, e); },
    map(e) { return this.pushStack(w.map(this, (t, n) => e.call(t, n, t))); },
    slice() { return this.pushStack(o.apply(this, arguments)); },
    first() { return this.eq(0); },
    last() { return this.eq(-1); },
    eq(e) {
      const t = this.length;
      const n = +e + (e < 0 ? t : 0); return this.pushStack(n >= 0 && n < t ? [this[n]] : []);
    },
    end() { return this.prevObject || this.constructor(); },
    push: s,
    sort: n.sort,
    splice: n.splice,
  }, w.extend = w.fn.extend = function () {
    let e; let t; let n; let r; let i; let o; let a = arguments[0] || {};
    let s = 1;
    const u = arguments.length;
    let l = !1; for (typeof a === 'boolean' && (l = a, a = arguments[s] || {}, s++), typeof a === 'object' || g(a) || (a = {}), s === u && (a = this, s--); s < u; s++) if ((e = arguments[s]) != null) for (t in e) n = a[t], a !== (r = e[t]) && (l && r && (w.isPlainObject(r) || (i = Array.isArray(r))) ? (i ? (i = !1, o = n && Array.isArray(n) ? n : []) : o = n && w.isPlainObject(n) ? n : {}, a[t] = w.extend(l, o, r)) : void 0 !== r && (a[t] = r));
    return a;
  }, w.extend({
    expando: `jQuery${(`3.3.1${Math.random()}`).replace(/\D/g, '')}`,
    isReady: !0,
    error(e) { throw new Error(e); },
    noop() {},
    isPlainObject(e) {
      let t; let
        n; return !(!e || c.call(e) !== '[object Object]') && (!(t = i(e)) || typeof (n = f.call(t, 'constructor') && t.constructor) === 'function' && p.call(n) === d);
    },
    isEmptyObject(e) { let t; for (t in e) return !1; return !0; },
    globalEval(e) { m(e); },
    each(e, t) {
      let n; let
        r = 0; if (C(e)) {
        for (n = e.length; r < n; r++) if (!1 === t.call(e[r], r, e[r])) break;
      } else for (r in e) if (!1 === t.call(e[r], r, e[r])) break; return e;
    },
    trim(e) { return e == null ? '' : (`${e}`).replace(T, ''); },
    makeArray(e, t) { const n = t || []; return e != null && (C(Object(e)) ? w.merge(n, typeof e === 'string' ? [e] : e) : s.call(n, e)), n; },
    inArray(e, t, n) { return t == null ? -1 : u.call(t, e, n); },
    merge(e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r]; return e.length = i, e; },
    grep(e, t, n) { for (var r, i = [], o = 0, a = e.length, s = !n; o < a; o++)(r = !t(e[o], o)) !== s && i.push(e[o]); return i; },
    map(e, t, n) {
      let r; let i; let o = 0;
      const s = []; if (C(e)) for (r = e.length; o < r; o++) (i = t(e[o], o, n)) != null && s.push(i);
      else for (o in e) (i = t(e[o], o, n)) != null && s.push(i); return a.apply([], s);
    },
    guid: 1,
    support: h,
  }), typeof Symbol === 'function' && (w.fn[Symbol.iterator] = n[Symbol.iterator]), w.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), (e, t) => { l[`[object ${t}]`] = t.toLowerCase(); });

  function C(e) {
    const t = !!e && 'length' in e && e.length;
    const n = x(e); return !g(e) && !y(e) && (n === 'array' || t === 0 || typeof t === 'number' && t > 0 && t - 1 in e);
  } const E = (function (e) {
    let t; let n; let r; let i; let o; let a; let s; let u; let l; let c; let f; let p; let d; let h; let g; let y; let v; let m; let x; const b = `sizzle${1 * new Date()}`;
    const w = e.document;
    let T = 0;
    let C = 0;
    const E = ae();
    const k = ae();
    const S = ae();
    let D = function (e, t) { return e === t && (f = !0), 0; };
    const N = {}.hasOwnProperty;
    let A = [];
    const j = A.pop;
    const q = A.push;
    let L = A.push;
    const H = A.slice;
    const O = function (e, t) {
      for (let n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;
      return -1;
    };
    const P = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped';
    const M = '[\\x20\\t\\r\\n\\f]';
    const R = '(?:\\\\.|[\\w-]|[^\0-\\xa0])+';
    const I = `\\[${M}*(${R})(?:${M}*([*^$|!~]?=)${M}*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(${R}))|)${M}*\\]`;
    const W = `:(${R})(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|${I})*)|.*)\\)|)`;
    const $ = new RegExp(`${M}+`, 'g');
    const B = new RegExp(`^${M}+|((?:^|[^\\\\])(?:\\\\.)*)${M}+$`, 'g');
    const F = new RegExp(`^${M}*,${M}*`);
    const _ = new RegExp(`^${M}*([>+~]|${M})${M}*`);
    const z = new RegExp(`=${M}*([^\\]'"]*?)${M}*\\]`, 'g');
    const X = new RegExp(W);
    const U = new RegExp(`^${R}$`);
    const V = {
      ID: new RegExp(`^#(${R})`), CLASS: new RegExp(`^\\.(${R})`), TAG: new RegExp(`^(${R}|[*])`), ATTR: new RegExp(`^${I}`), PSEUDO: new RegExp(`^${W}`), CHILD: new RegExp(`^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(${M}*(even|odd|(([+-]|)(\\d*)n|)${M}*(?:([+-]|)${M}*(\\d+)|))${M}*\\)|)`, 'i'), bool: new RegExp(`^(?:${P})$`, 'i'), needsContext: new RegExp(`^${M}*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(${M}*((?:-\\d)?\\d*)${M}*\\)|)(?=[^-]|$)`, 'i'),
    };
    const G = /^(?:input|select|textarea|button)$/i;
    const Y = /^h\d$/i;
    const Q = /^[^{]+\{\s*\[native \w/;
    const J = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/;
    const K = /[+~]/;
    const Z = new RegExp(`\\\\([\\da-f]{1,6}${M}?|(${M})|.)`, 'ig');
    const ee = function (e, t, n) { const r = `0x${t}` - 65536; return r !== r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320); };
    const te = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g;
    const ne = function (e, t) { return t ? e === '\0' ? '\ufffd' : `${e.slice(0, -1)}\\${e.charCodeAt(e.length - 1).toString(16)} ` : `\\${e}`; };
    const re = function () { p(); };
    const ie = me((e) => !0 === e.disabled && ('form' in e || 'label' in e), { dir: 'parentNode', next: 'legend' }); try { L.apply(A = H.call(w.childNodes), w.childNodes), A[w.childNodes.length].nodeType; } catch (e) {
      L = {
        apply: A.length ? function (e, t) { q.apply(e, H.call(t)); } : function (e, t) {
          let n = e.length;
          let r = 0; while (e[n++] = t[r++]);
          e.length = n - 1;
        },
      };
    }

    function oe(e, t, r, i) {
      let o; let s; let l; let c; let f; let h; let v; let m = t && t.ownerDocument;
      const T = t ? t.nodeType : 9; if (r = r || [], typeof e !== 'string' || !e || T !== 1 && T !== 9 && T !== 11) return r; if (!i && ((t ? t.ownerDocument || t : w) !== d && p(t), t = t || d, g)) {
        if (T !== 11 && (f = J.exec(e))) if (o = f[1]) { if (T === 9) { if (!(l = t.getElementById(o))) return r; if (l.id === o) return r.push(l), r; } else if (m && (l = m.getElementById(o)) && x(t, l) && l.id === o) return r.push(l), r; } else { if (f[2]) return L.apply(r, t.getElementsByTagName(e)), r; if ((o = f[3]) && n.getElementsByClassName && t.getElementsByClassName) return L.apply(r, t.getElementsByClassName(o)), r; }
        if (n.qsa && !S[`${e} `] && (!y || !y.test(e))) {
          if (T !== 1) m = t, v = e;
          else if (t.nodeName.toLowerCase() !== 'object') {
            (c = t.getAttribute('id')) ? c = c.replace(te, ne) : t.setAttribute('id', c = b), s = (h = a(e)).length; while (s--) h[s] = `#${c} ${ve(h[s])}`;
            v = h.join(','), m = K.test(e) && ge(t.parentNode) || t;
          } if (v) try { return L.apply(r, m.querySelectorAll(v)), r; } catch (e) {} finally { c === b && t.removeAttribute('id'); }
        }
      } return u(e.replace(B, '$1'), t, r, i);
    }

    function ae() {
      const e = [];

      function t(n, i) { return e.push(`${n} `) > r.cacheLength && delete t[e.shift()], t[`${n} `] = i; } return t;
    }

    function se(e) { return e[b] = !0, e; }

    function ue(e) { let t = d.createElement('fieldset'); try { return !!e(t); } catch (e) { return !1; } finally { t.parentNode && t.parentNode.removeChild(t), t = null; } }

    function le(e, t) {
      const n = e.split('|');
      let i = n.length; while (i--) r.attrHandle[n[i]] = t;
    }

    function ce(e, t) {
      let n = t && e;
      const r = n && e.nodeType === 1 && t.nodeType === 1 && e.sourceIndex - t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return -1;
      return e ? 1 : -1;
    }

    function fe(e) { return function (t) { return t.nodeName.toLowerCase() === 'input' && t.type === e; }; }

    function pe(e) { return function (t) { const n = t.nodeName.toLowerCase(); return (n === 'input' || n === 'button') && t.type === e; }; }

    function de(e) { return function (t) { return 'form' in t ? t.parentNode && !1 === t.disabled ? 'label' in t ? 'label' in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && ie(t) === e : t.disabled === e : 'label' in t && t.disabled === e; }; }

    function he(e) {
      return se((t) => (t = +t, se((n, r) => {
        let i; const o = e([], n.length, t);
        let a = o.length; while (a--) n[i = o[a]] && (n[i] = !(r[i] = n[i]));
      })));
    }

    function ge(e) { return e && typeof e.getElementsByTagName !== 'undefined' && e; }
    n = oe.support = {}, o = oe.isXML = function (e) { const t = e && (e.ownerDocument || e).documentElement; return !!t && t.nodeName !== 'HTML'; }, p = oe.setDocument = function (e) {
      let t; let i; const
        a = e ? e.ownerDocument || e : w; return a !== d && a.nodeType === 9 && a.documentElement ? (d = a, h = d.documentElement, g = !o(d), w !== d && (i = d.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener('unload', re, !1) : i.attachEvent && i.attachEvent('onunload', re)), n.attributes = ue((e) => (e.className = 'i', !e.getAttribute('className'))), n.getElementsByTagName = ue((e) => (e.appendChild(d.createComment('')), !e.getElementsByTagName('*').length)), n.getElementsByClassName = Q.test(d.getElementsByClassName), n.getById = ue((e) => (h.appendChild(e).id = b, !d.getElementsByName || !d.getElementsByName(b).length)), n.getById ? (r.filter.ID = function (e) { const t = e.replace(Z, ee); return function (e) { return e.getAttribute('id') === t; }; }, r.find.ID = function (e, t) { if (typeof t.getElementById !== 'undefined' && g) { const n = t.getElementById(e); return n ? [n] : []; } }) : (r.filter.ID = function (e) { const t = e.replace(Z, ee); return function (e) { const n = typeof e.getAttributeNode !== 'undefined' && e.getAttributeNode('id'); return n && n.value === t; }; }, r.find.ID = function (e, t) {
        if (typeof t.getElementById !== 'undefined' && g) {
          let n; let r; let i; let
            o = t.getElementById(e); if (o) {
            if ((n = o.getAttributeNode('id')) && n.value === e) return [o];
            i = t.getElementsByName(e), r = 0; while (o = i[r++]) if ((n = o.getAttributeNode('id')) && n.value === e) return [o];
          } return [];
        }
      }), r.find.TAG = n.getElementsByTagName ? function (e, t) { return typeof t.getElementsByTagName !== 'undefined' ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0; } : function (e, t) {
        let n; const r = [];
        let i = 0;
        const o = t.getElementsByTagName(e); if (e === '*') { while (n = o[i++]) n.nodeType === 1 && r.push(n); return r; } return o;
      }, r.find.CLASS = n.getElementsByClassName && function (e, t) { if (typeof t.getElementsByClassName !== 'undefined' && g) return t.getElementsByClassName(e); }, v = [], y = [], (n.qsa = Q.test(d.querySelectorAll)) && (ue((e) => { h.appendChild(e).innerHTML = `<a id='${b}'></a><select id='${b}-\r\\' msallowcapture=''><option selected=''></option></select>`, e.querySelectorAll("[msallowcapture^='']").length && y.push(`[*^$]=${M}*(?:''|"")`), e.querySelectorAll('[selected]').length || y.push(`\\[${M}*(?:value|${P})`), e.querySelectorAll(`[id~=${b}-]`).length || y.push('~='), e.querySelectorAll(':checked').length || y.push(':checked'), e.querySelectorAll(`a#${b}+*`).length || y.push('.#.+[+~]'); }), ue((e) => {
        e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; const t = d.createElement('input');
        t.setAttribute('type', 'hidden'), e.appendChild(t).setAttribute('name', 'D'), e.querySelectorAll('[name=d]').length && y.push(`name${M}*[*^$|!~]?=`), e.querySelectorAll(':enabled').length !== 2 && y.push(':enabled', ':disabled'), h.appendChild(e).disabled = !0, e.querySelectorAll(':disabled').length !== 2 && y.push(':enabled', ':disabled'), e.querySelectorAll('*,:x'), y.push(',.*:');
      })), (n.matchesSelector = Q.test(m = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ue((e) => { n.disconnectedMatch = m.call(e, '*'), m.call(e, "[s!='']:x"), v.push('!=', W); }), y = y.length && new RegExp(y.join('|')), v = v.length && new RegExp(v.join('|')), t = Q.test(h.compareDocumentPosition), x = t || Q.test(h.contains) ? function (e, t) {
        const n = e.nodeType === 9 ? e.documentElement : e;
        const r = t && t.parentNode; return e === r || !(!r || r.nodeType !== 1 || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)));
      } : function (e, t) {
        if (t) while (t = t.parentNode) if (t === e) return !0;
        return !1;
      }, D = t ? function (e, t) { if (e === t) return f = !0, 0; let r = !e.compareDocumentPosition - !t.compareDocumentPosition; return r || (1 & (r = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === r ? e === d || e.ownerDocument === w && x(w, e) ? -1 : t === d || t.ownerDocument === w && x(w, t) ? 1 : c ? O(c, e) - O(c, t) : 0 : 4 & r ? -1 : 1); } : function (e, t) {
        if (e === t) return f = !0, 0; let n; let r = 0;
        const i = e.parentNode;
        const o = t.parentNode;
        const a = [e];
        const s = [t]; if (!i || !o) return e === d ? -1 : t === d ? 1 : i ? -1 : o ? 1 : c ? O(c, e) - O(c, t) : 0; if (i === o) return ce(e, t);
        n = e; while (n = n.parentNode) a.unshift(n);
        n = t; while (n = n.parentNode) s.unshift(n); while (a[r] === s[r]) r++; return r ? ce(a[r], s[r]) : a[r] === w ? -1 : s[r] === w ? 1 : 0;
      }, d) : d;
    }, oe.matches = function (e, t) { return oe(e, null, null, t); }, oe.matchesSelector = function (e, t) {
      if ((e.ownerDocument || e) !== d && p(e), t = t.replace(z, "='$1']"), n.matchesSelector && g && !S[`${t} `] && (!v || !v.test(t)) && (!y || !y.test(t))) try { const r = m.call(e, t); if (r || n.disconnectedMatch || e.document && e.document.nodeType !== 11) return r; } catch (e) {}
      return oe(t, d, null, [e]).length > 0;
    }, oe.contains = function (e, t) { return (e.ownerDocument || e) !== d && p(e), x(e, t); }, oe.attr = function (e, t) {
      (e.ownerDocument || e) !== d && p(e); const i = r.attrHandle[t.toLowerCase()];
      let o = i && N.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !g) : void 0; return void 0 !== o ? o : n.attributes || !g ? e.getAttribute(t) : (o = e.getAttributeNode(t)) && o.specified ? o.value : null;
    }, oe.escape = function (e) { return (`${e}`).replace(te, ne); }, oe.error = function (e) { throw new Error(`Syntax error, unrecognized expression: ${e}`); }, oe.uniqueSort = function (e) {
      let t; const r = [];
      let i = 0;
      let o = 0; if (f = !n.detectDuplicates, c = !n.sortStable && e.slice(0), e.sort(D), f) { while (t = e[o++]) t === e[o] && (i = r.push(o)); while (i--) e.splice(r[i], 1); } return c = null, e;
    }, i = oe.getText = function (e) {
      let t; let n = '';
      let r = 0;
      const o = e.nodeType; if (o) { if (o === 1 || o === 9 || o === 11) { if (typeof e.textContent === 'string') return e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n += i(e); } else if (o === 3 || o === 4) return e.nodeValue; } else while (t = e[r++]) n += i(t); return n;
    }, (r = oe.selectors = {
      cacheLength: 50,
      createPseudo: se,
      match: V,
      attrHandle: {},
      find: {},
      relative: {
        '>': { dir: 'parentNode', first: !0 }, ' ': { dir: 'parentNode' }, '+': { dir: 'previousSibling', first: !0 }, '~': { dir: 'previousSibling' },
      },
      preFilter: {
        ATTR(e) { return e[1] = e[1].replace(Z, ee), e[3] = (e[3] || e[4] || e[5] || '').replace(Z, ee), e[2] === '~=' && (e[3] = ` ${e[3]} `), e.slice(0, 4); },
        CHILD(e) { return e[1] = e[1].toLowerCase(), e[1].slice(0, 3) === 'nth' ? (e[3] || oe.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * (e[3] === 'even' || e[3] === 'odd')), e[5] = +(e[7] + e[8] || e[3] === 'odd')) : e[3] && oe.error(e[0]), e; },
        PSEUDO(e) {
          let t; const
            n = !e[6] && e[2]; return V.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || '' : n && X.test(n) && (t = a(n, !0)) && (t = n.indexOf(')', n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3));
        },
      },
      filter: {
        TAG(e) { const t = e.replace(Z, ee).toLowerCase(); return e === '*' ? function () { return !0; } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t; }; },
        CLASS(e) { let t = E[`${e} `]; return t || (t = new RegExp(`(^|${M})${e}(${M}|$)`)) && E(e, (e) => t.test(typeof e.className === 'string' && e.className || typeof e.getAttribute !== 'undefined' && e.getAttribute('class') || '')); },
        ATTR(e, t, n) { return function (r) { let i = oe.attr(r, e); return i == null ? t === '!=' : !t || (i += '', t === '=' ? i === n : t === '!=' ? i !== n : t === '^=' ? n && i.indexOf(n) === 0 : t === '*=' ? n && i.indexOf(n) > -1 : t === '$=' ? n && i.slice(-n.length) === n : t === '~=' ? (` ${i.replace($, ' ')} `).indexOf(n) > -1 : t === '|=' && (i === n || i.slice(0, n.length + 1) === `${n}-`)); }; },
        CHILD(e, t, n, r, i) {
          const o = e.slice(0, 3) !== 'nth';
          const a = e.slice(-4) !== 'last';
          const s = t === 'of-type'; return r === 1 && i === 0 ? function (e) { return !!e.parentNode; } : function (t, n, u) {
            let l; let c; let f; let p; let d; let h; let g = o !== a ? 'nextSibling' : 'previousSibling';
            const y = t.parentNode;
            const v = s && t.nodeName.toLowerCase();
            const m = !u && !s;
            let x = !1; if (y) {
              if (o) {
                while (g) {
                  p = t; while (p = p[g]) if (s ? p.nodeName.toLowerCase() === v : p.nodeType === 1) return !1;
                  h = g = e === 'only' && !h && 'nextSibling';
                } return !0;
              } if (h = [a ? y.firstChild : y.lastChild], a && m) {
                x = (d = (l = (c = (f = (p = y)[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] || [])[0] === T && l[1]) && l[2], p = d && y.childNodes[d]; while (p = ++d && p && p[g] || (x = d = 0) || h.pop()) if (p.nodeType === 1 && ++x && p === t) { c[e] = [T, d, x]; break; }
              } else if (m && (x = d = (l = (c = (f = (p = t)[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] || [])[0] === T && l[1]), !1 === x) while (p = ++d && p && p[g] || (x = d = 0) || h.pop()) if ((s ? p.nodeName.toLowerCase() === v : p.nodeType === 1) && ++x && (m && ((c = (f = p[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] = [T, x]), p === t)) break;
              return (x -= i) === r || x % r == 0 && x / r >= 0;
            }
          };
        },
        PSEUDO(e, t) {
          let n; const
            i = r.pseudos[e] || r.setFilters[e.toLowerCase()] || oe.error(`unsupported pseudo: ${e}`); return i[b] ? i(t) : i.length > 1 ? (n = [e, e, '', t], r.setFilters.hasOwnProperty(e.toLowerCase()) ? se((e, n) => {
            let r; const o = i(e, t);
            let a = o.length; while (a--) e[r = O(e, o[a])] = !(n[r] = o[a]);
          }) : function (e) { return i(e, 0, n); }) : i;
        },
      },
      pseudos: {
        not: se((e) => {
          const t = [];
          const n = [];
          const r = s(e.replace(B, '$1')); return r[b] ? se((e, t, n, i) => {
            let o; const a = r(e, null, i, []);
            let s = e.length; while (s--)(o = a[s]) && (e[s] = !(t[s] = o));
          }) : function (e, i, o) { return t[0] = e, r(t, null, o, n), t[0] = null, !n.pop(); };
        }),
        has: se((e) => function (t) { return oe(e, t).length > 0; }),
        contains: se((e) => (e = e.replace(Z, ee),
        function (t) { return (t.textContent || t.innerText || i(t)).indexOf(e) > -1; })),
        lang: se((e) => (U.test(e || '') || oe.error(`unsupported lang: ${e}`), e = e.replace(Z, ee).toLowerCase(),
        function (t) {
          let n;
          do { if (n = g ? t.lang : t.getAttribute('xml:lang') || t.getAttribute('lang')) return (n = n.toLowerCase()) === e || n.indexOf(`${e}-`) === 0; } while ((t = t.parentNode) && t.nodeType === 1); return !1;
        })),
        target(t) { const n = e.location && e.location.hash; return n && n.slice(1) === t.id; },
        root(e) { return e === h; },
        focus(e) { return e === d.activeElement && (!d.hasFocus || d.hasFocus()) && !!(e.type || e.href || ~e.tabIndex); },
        enabled: de(!1),
        disabled: de(!0),
        checked(e) { const t = e.nodeName.toLowerCase(); return t === 'input' && !!e.checked || t === 'option' && !!e.selected; },
        selected(e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected; },
        empty(e) {
          for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;
          return !0;
        },
        parent(e) { return !r.pseudos.empty(e); },
        header(e) { return Y.test(e.nodeName); },
        input(e) { return G.test(e.nodeName); },
        button(e) { const t = e.nodeName.toLowerCase(); return t === 'input' && e.type === 'button' || t === 'button'; },
        text(e) { let t; return e.nodeName.toLowerCase() === 'input' && e.type === 'text' && ((t = e.getAttribute('type')) == null || t.toLowerCase() === 'text'); },
        first: he(() => [0]),
        last: he((e, t) => [t - 1]),
        eq: he((e, t, n) => [n < 0 ? n + t : n]),
        even: he((e, t) => { for (let n = 0; n < t; n += 2) e.push(n); return e; }),
        odd: he((e, t) => { for (let n = 1; n < t; n += 2) e.push(n); return e; }),
        lt: he((e, t, n) => { for (let r = n < 0 ? n + t : n; --r >= 0;) e.push(r); return e; }),
        gt: he((e, t, n) => { for (let r = n < 0 ? n + t : n; ++r < t;) e.push(r); return e; }),
      },
    }).pseudos.nth = r.pseudos.eq; for (t in {
      radio: !0, checkbox: !0, file: !0, password: !0, image: !0,
    }) r.pseudos[t] = fe(t); for (t in { submit: !0, reset: !0 }) r.pseudos[t] = pe(t);

    function ye() {}
    ye.prototype = r.filters = r.pseudos, r.setFilters = new ye(), a = oe.tokenize = function (e, t) {
      let n; let i; let o; let a; let s; let u; let l; const
        c = k[`${e} `]; if (c) return t ? 0 : c.slice(0);
      s = e, u = [], l = r.preFilter; while (s) { n && !(i = F.exec(s)) || (i && (s = s.slice(i[0].length) || s), u.push(o = [])), n = !1, (i = _.exec(s)) && (n = i.shift(), o.push({ value: n, type: i[0].replace(B, ' ') }), s = s.slice(n.length)); for (a in r.filter) !(i = V[a].exec(s)) || l[a] && !(i = l[a](i)) || (n = i.shift(), o.push({ value: n, type: a, matches: i }), s = s.slice(n.length)); if (!n) break; } return t ? s.length : s ? oe.error(e) : k(e, u).slice(0);
    };

    function ve(e) { for (var t = 0, n = e.length, r = ''; t < n; t++) r += e[t].value; return r; }

    function me(e, t, n) {
      const r = t.dir;
      const i = t.next;
      const o = i || r;
      const a = n && o === 'parentNode';
      const s = C++; return t.first ? function (t, n, i) {
        while (t = t[r]) if (t.nodeType === 1 || a) return e(t, n, i);
        return !1;
      } : function (t, n, u) {
        let l; let c; let f; const
          p = [T, s]; if (u) {
          while (t = t[r]) if ((t.nodeType === 1 || a) && e(t, n, u)) return !0;
        } else {
          while (t = t[r]) {
            if (t.nodeType === 1 || a) {
              if (f = t[b] || (t[b] = {}), c = f[t.uniqueID] || (f[t.uniqueID] = {}), i && i === t.nodeName.toLowerCase()) t = t[r] || t;
              else { if ((l = c[o]) && l[0] === T && l[1] === s) return p[2] = l[2]; if (c[o] = p, p[2] = e(t, n, u)) return !0; }
            }
          }
        } return !1;
      };
    }

    function xe(e) {
      return e.length > 1 ? function (t, n, r) {
        let i = e.length; while (i--) if (!e[i](t, n, r)) return !1;
        return !0;
      } : e[0];
    }

    function be(e, t, n) { for (let r = 0, i = t.length; r < i; r++) oe(e, t[r], n); return n; }

    function we(e, t, n, r, i) { for (var o, a = [], s = 0, u = e.length, l = t != null; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s))); return a; }

    function Te(e, t, n, r, i, o) {
      return r && !r[b] && (r = Te(r)), i && !i[b] && (i = Te(i, o)), se((o, a, s, u) => {
        let l; let c; let f; const p = [];
        const d = [];
        const h = a.length;
        const g = o || be(t || '*', s.nodeType ? [s] : s, []);
        const y = !e || !o && t ? g : we(g, p, e, s, u);
        let v = n ? i || (o ? e : h || r) ? [] : a : y; if (n && n(y, v, s, u), r) { l = we(v, d), r(l, [], s, u), c = l.length; while (c--)(f = l[c]) && (v[d[c]] = !(y[d[c]] = f)); } if (o) {
          if (i || e) {
            if (i) {
              l = [], c = v.length; while (c--)(f = v[c]) && l.push(y[c] = f);
              i(null, v = [], l, u);
            }
            c = v.length; while (c--)(f = v[c]) && (l = i ? O(o, f) : p[c]) > -1 && (o[l] = !(a[l] = f));
          }
        } else v = we(v === a ? v.splice(h, v.length) : v), i ? i(null, a, v, u) : L.apply(a, v);
      });
    }

    function Ce(e) {
      for (var t, n, i, o = e.length, a = r.relative[e[0].type], s = a || r.relative[' '], u = a ? 1 : 0, c = me((e) => e === t, s, !0), f = me((e) => O(t, e) > -1, s, !0), p = [function (e, n, r) { const i = !a && (r || n !== l) || ((t = n).nodeType ? c(e, n, r) : f(e, n, r)); return t = null, i; }]; u < o; u++) {
        if (n = r.relative[e[u].type]) p = [me(xe(p), n)];
        else {
          if ((n = r.filter[e[u].type].apply(null, e[u].matches))[b]) {
            for (i = ++u; i < o; i++) if (r.relative[e[i].type]) break;
            return Te(u > 1 && xe(p), u > 1 && ve(e.slice(0, u - 1).concat({ value: e[u - 2].type === ' ' ? '*' : '' })).replace(B, '$1'), n, u < i && Ce(e.slice(u, i)), i < o && Ce(e = e.slice(i)), i < o && ve(e));
          }
          p.push(n);
        }
      }
      return xe(p);
    }

    function Ee(e, t) {
      const n = t.length > 0;
      const i = e.length > 0;
      const o = function (o, a, s, u, c) {
        let f; let h; let y; let v = 0;
        let m = '0';
        const x = o && [];
        let b = [];
        const w = l;
        const C = o || i && r.find.TAG('*', c);
        const E = T += w == null ? 1 : Math.random() || 0.1;
        const k = C.length; for (c && (l = a === d || a || c); m !== k && (f = C[m]) != null; m++) {
          if (i && f) {
            h = 0, a || f.ownerDocument === d || (p(f), s = !g); while (y = e[h++]) if (y(f, a || d, s)) { u.push(f); break; }
            c && (T = E);
          }
          n && ((f = !y && f) && v--, o && x.push(f));
        } if (v += m, n && m !== v) {
          h = 0; while (y = t[h++]) y(x, b, a, s); if (o) {
            if (v > 0) while (m--) x[m] || b[m] || (b[m] = j.call(u));
            b = we(b);
          }
          L.apply(u, b), c && !o && b.length > 0 && v + t.length > 1 && oe.uniqueSort(u);
        } return c && (T = E, l = w), x;
      }; return n ? se(o) : o;
    } return s = oe.compile = function (e, t) {
      let n; const r = [];
      const i = [];
      let o = S[`${e} `]; if (!o) {
        t || (t = a(e)), n = t.length; while (n--)(o = Ce(t[n]))[b] ? r.push(o) : i.push(o);
        (o = S(e, Ee(i, r))).selector = e;
      } return o;
    }, u = oe.select = function (e, t, n, i) {
      let o; let u; let l; let c; let f; const p = typeof e === 'function' && e;
      const d = !i && a(e = p.selector || e); if (n = n || [], d.length === 1) {
        if ((u = d[0] = d[0].slice(0)).length > 2 && (l = u[0]).type === 'ID' && t.nodeType === 9 && g && r.relative[u[1].type]) {
          if (!(t = (r.find.ID(l.matches[0].replace(Z, ee), t) || [])[0])) return n;
          p && (t = t.parentNode), e = e.slice(u.shift().value.length);
        }
        o = V.needsContext.test(e) ? 0 : u.length; while (o--) { if (l = u[o], r.relative[c = l.type]) break; if ((f = r.find[c]) && (i = f(l.matches[0].replace(Z, ee), K.test(u[0].type) && ge(t.parentNode) || t))) { if (u.splice(o, 1), !(e = i.length && ve(u))) return L.apply(n, i), n; break; } }
      } return (p || s(e, d))(i, t, !g, n, !t || K.test(e) && ge(t.parentNode) || t), n;
    }, n.sortStable = b.split('').sort(D).join('') === b, n.detectDuplicates = !!f, p(), n.sortDetached = ue((e) => 1 & e.compareDocumentPosition(d.createElement('fieldset'))), ue((e) => (e.innerHTML = "<a href='#'></a>", e.firstChild.getAttribute('href') === '#')) || le('type|href|height|width', (e, t, n) => { if (!n) return e.getAttribute(t, t.toLowerCase() === 'type' ? 1 : 2); }), n.attributes && ue((e) => (e.innerHTML = '<input/>', e.firstChild.setAttribute('value', ''), e.firstChild.getAttribute('value') === '')) || le('value', (e, t, n) => { if (!n && e.nodeName.toLowerCase() === 'input') return e.defaultValue; }), ue((e) => e.getAttribute('disabled') == null) || le(P, (e, t, n) => { let r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null; }), oe;
  }(e));
  w.find = E, w.expr = E.selectors, w.expr[':'] = w.expr.pseudos, w.uniqueSort = w.unique = E.uniqueSort, w.text = E.getText, w.isXMLDoc = E.isXML, w.contains = E.contains, w.escapeSelector = E.escape; const k = function (e, t, n) {
    const r = [];
    const i = void 0 !== n; while ((e = e[t]) && e.nodeType !== 9) {
      if (e.nodeType === 1) {
        if (i && w(e).is(n)) break;
        r.push(e);
      }
    }
    return r;
  };
  const S = function (e, t) { for (var n = []; e; e = e.nextSibling) e.nodeType === 1 && e !== t && n.push(e); return n; };
  const D = w.expr.match.needsContext;

  function N(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase(); } const A = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

  function j(e, t, n) { return g(t) ? w.grep(e, (e, r) => !!t.call(e, r, e) !== n) : t.nodeType ? w.grep(e, (e) => e === t !== n) : typeof t !== 'string' ? w.grep(e, (e) => u.call(t, e) > -1 !== n) : w.filter(t, e, n); }
  w.filter = function (e, t, n) { const r = t[0]; return n && (e = `:not(${e})`), t.length === 1 && r.nodeType === 1 ? w.find.matchesSelector(r, e) ? [r] : [] : w.find.matches(e, w.grep(t, (e) => e.nodeType === 1)); }, w.fn.extend({
    find(e) {
      let t; let n; const r = this.length;
      const i = this; if (typeof e !== 'string') {
        return this.pushStack(w(e).filter(function () {
          for (t = 0; t < r; t++) if (w.contains(i[t], this)) return !0;
        }));
      } for (n = this.pushStack([]), t = 0; t < r; t++) w.find(e, i[t], n); return r > 1 ? w.uniqueSort(n) : n;
    },
    filter(e) { return this.pushStack(j(this, e || [], !1)); },
    not(e) { return this.pushStack(j(this, e || [], !0)); },
    is(e) { return !!j(this, typeof e === 'string' && D.test(e) ? w(e) : e || [], !1).length; },
  }); let q; const
    L = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
  (w.fn.init = function (e, t, n) {
    let i; let
      o; if (!e) return this; if (n = n || q, typeof e === 'string') {
      if (!(i = e[0] === '<' && e[e.length - 1] === '>' && e.length >= 3 ? [null, e, null] : L.exec(e)) || !i[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (i[1]) {
        if (t = t instanceof w ? t[0] : t, w.merge(this, w.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : r, !0)), A.test(i[1]) && w.isPlainObject(t)) for (i in t) g(this[i]) ? this[i](t[i]) : this.attr(i, t[i]); return this;
      } return (o = r.getElementById(i[2])) && (this[0] = o, this.length = 1), this;
    } return e.nodeType ? (this[0] = e, this.length = 1, this) : g(e) ? void 0 !== n.ready ? n.ready(e) : e(w) : w.makeArray(e, this);
  }).prototype = w.fn, q = w(r); const H = /^(?:parents|prev(?:Until|All))/;
  const O = {
    children: !0, contents: !0, next: !0, prev: !0,
  };
  w.fn.extend({
    has(e) {
      const t = w(e, this);
      const n = t.length; return this.filter(function () {
        for (let e = 0; e < n; e++) if (w.contains(this, t[e])) return !0;
      });
    },
    closest(e, t) {
      let n; let r = 0;
      const i = this.length;
      const o = [];
      const a = typeof e !== 'string' && w(e); if (!D.test(e)) for (; r < i; r++) for (n = this[r]; n && n !== t; n = n.parentNode) if (n.nodeType < 11 && (a ? a.index(n) > -1 : n.nodeType === 1 && w.find.matchesSelector(n, e))) { o.push(n); break; }
      return this.pushStack(o.length > 1 ? w.uniqueSort(o) : o);
    },
    index(e) { return e ? typeof e === 'string' ? u.call(w(e), this[0]) : u.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1; },
    add(e, t) { return this.pushStack(w.uniqueSort(w.merge(this.get(), w(e, t)))); },
    addBack(e) { return this.add(e == null ? this.prevObject : this.prevObject.filter(e)); },
  });

  function P(e, t) { while ((e = e[t]) && e.nodeType !== 1); return e; }
  w.each({
    parent(e) { const t = e.parentNode; return t && t.nodeType !== 11 ? t : null; }, parents(e) { return k(e, 'parentNode'); }, parentsUntil(e, t, n) { return k(e, 'parentNode', n); }, next(e) { return P(e, 'nextSibling'); }, prev(e) { return P(e, 'previousSibling'); }, nextAll(e) { return k(e, 'nextSibling'); }, prevAll(e) { return k(e, 'previousSibling'); }, nextUntil(e, t, n) { return k(e, 'nextSibling', n); }, prevUntil(e, t, n) { return k(e, 'previousSibling', n); }, siblings(e) { return S((e.parentNode || {}).firstChild, e); }, children(e) { return S(e.firstChild); }, contents(e) { return N(e, 'iframe') ? e.contentDocument : (N(e, 'template') && (e = e.content || e), w.merge([], e.childNodes)); },
  }, (e, t) => { w.fn[e] = function (n, r) { let i = w.map(this, t, n); return e.slice(-5) !== 'Until' && (r = n), r && typeof r === 'string' && (i = w.filter(r, i)), this.length > 1 && (O[e] || w.uniqueSort(i), H.test(e) && i.reverse()), this.pushStack(i); }; }); const M = /[^\x20\t\r\n\f]+/g;

  function R(e) { const t = {}; return w.each(e.match(M) || [], (e, n) => { t[n] = !0; }), t; }
  w.Callbacks = function (e) {
    e = typeof e === 'string' ? R(e) : w.extend({}, e); let t; let n; let r; let i; let o = [];
    let a = [];
    let s = -1;
    const u = function () {
      for (i = i || e.once, r = t = !0; a.length; s = -1) { n = a.shift(); while (++s < o.length) !1 === o[s].apply(n[0], n[1]) && e.stopOnFalse && (s = o.length, n = !1); }
      e.memory || (n = !1), t = !1, i && (o = n ? [] : '');
    };
    var l = {
      add() { return o && (n && !t && (s = o.length - 1, a.push(n)), (function t(n) { w.each(n, (n, r) => { g(r) ? e.unique && l.has(r) || o.push(r) : r && r.length && x(r) !== 'string' && t(r); }); }(arguments)), n && !t && u()), this; }, remove() { return w.each(arguments, (e, t) => { let n; while ((n = w.inArray(t, o, n)) > -1) o.splice(n, 1), n <= s && s--; }), this; }, has(e) { return e ? w.inArray(e, o) > -1 : o.length > 0; }, empty() { return o && (o = []), this; }, disable() { return i = a = [], o = n = '', this; }, disabled() { return !o; }, lock() { return i = a = [], n || t || (o = n = ''), this; }, locked() { return !!i; }, fireWith(e, n) { return i || (n = [e, (n = n || []).slice ? n.slice() : n], a.push(n), t || u()), this; }, fire() { return l.fireWith(this, arguments), this; }, fired() { return !!r; },
    }; return l;
  };

  function I(e) { return e; }

  function W(e) { throw e; }

  function $(e, t, n, r) { let i; try { e && g(i = e.promise) ? i.call(e).done(t).fail(n) : e && g(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r)); } catch (e) { n.apply(void 0, [e]); } }
  w.extend({
    Deferred(t) {
      const n = [
        ['notify', 'progress', w.Callbacks('memory'), w.Callbacks('memory'), 2],
        ['resolve', 'done', w.Callbacks('once memory'), w.Callbacks('once memory'), 0, 'resolved'],
        ['reject', 'fail', w.Callbacks('once memory'), w.Callbacks('once memory'), 1, 'rejected'],
      ];
      let r = 'pending';
      var i = {
        state() { return r; },
        always() { return o.done(arguments).fail(arguments), this; },
        catch(e) { return i.then(null, e); },
        pipe() {
          let e = arguments; return w.Deferred((t) => {
            w.each(n, (n, r) => {
              const i = g(e[r[4]]) && e[r[4]];
              o[r[1]](function () {
                const e = i && i.apply(this, arguments);
                e && g(e.promise) ? e.promise().progress(t.notify).done(t.resolve).fail(t.reject) : t[`${r[0]}With`](this, i ? [e] : arguments);
              });
            }), e = null;
          }).promise();
        },
        then(t, r, i) {
          let o = 0;

          function a(t, n, r, i) {
            return function () {
              let s = this;
              let u = arguments;
              const l = function () {
                let e; let
                  l; if (!(t < o)) {
                  if ((e = r.apply(s, u)) === n.promise()) throw new TypeError('Thenable self-resolution');
                  l = e && (typeof e === 'object' || typeof e === 'function') && e.then, g(l) ? i ? l.call(e, a(o, n, I, i), a(o, n, W, i)) : (o++, l.call(e, a(o, n, I, i), a(o, n, W, i), a(o, n, I, n.notifyWith))) : (r !== I && (s = void 0, u = [e]), (i || n.resolveWith)(s, u));
                }
              };
              var c = i ? l : function () { try { l(); } catch (e) { w.Deferred.exceptionHook && w.Deferred.exceptionHook(e, c.stackTrace), t + 1 >= o && (r !== W && (s = void 0, u = [e]), n.rejectWith(s, u)); } };
              t ? c() : (w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook()), e.setTimeout(c));
            };
          } return w.Deferred((e) => { n[0][3].add(a(0, e, g(i) ? i : I, e.notifyWith)), n[1][3].add(a(0, e, g(t) ? t : I)), n[2][3].add(a(0, e, g(r) ? r : W)); }).promise();
        },
        promise(e) { return e != null ? w.extend(e, i) : i; },
      };
      var o = {}; return w.each(n, (e, t) => {
        const a = t[2];
        const s = t[5];
        i[t[1]] = a.add, s && a.add(() => { r = s; }, n[3 - e][2].disable, n[3 - e][3].disable, n[0][2].lock, n[0][3].lock), a.add(t[3].fire), o[t[0]] = function () { return o[`${t[0]}With`](this === o ? void 0 : this, arguments), this; }, o[`${t[0]}With`] = a.fireWith;
      }), i.promise(o), t && t.call(o, o), o;
    },
    when(e) {
      let t = arguments.length;
      let n = t;
      const r = Array(n);
      const i = o.call(arguments);
      const a = w.Deferred();
      const s = function (e) { return function (n) { r[e] = this, i[e] = arguments.length > 1 ? o.call(arguments) : n, --t || a.resolveWith(r, i); }; }; if (t <= 1 && ($(e, a.done(s(n)).resolve, a.reject, !t), a.state() === 'pending' || g(i[n] && i[n].then))) return a.then(); while (n--) $(i[n], s(n), a.reject); return a.promise();
    },
  }); const B = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  w.Deferred.exceptionHook = function (t, n) { e.console && e.console.warn && t && B.test(t.name) && e.console.warn(`jQuery.Deferred exception: ${t.message}`, t.stack, n); }, w.readyException = function (t) { e.setTimeout(() => { throw t; }); }; const F = w.Deferred();
  w.fn.ready = function (e) { return F.then(e).catch((e) => { w.readyException(e); }), this; }, w.extend({
    isReady: !1,
    readyWait: 1,
    ready(e) {
      (!0 === e ? --w.readyWait : w.isReady) || (w.isReady = !0, !0 !== e && --w.readyWait > 0 || F.resolveWith(r, [w]));
    },
  }), w.ready.then = F.then;

  function _() { r.removeEventListener('DOMContentLoaded', _), e.removeEventListener('load', _), w.ready(); } r.readyState === 'complete' || r.readyState !== 'loading' && !r.documentElement.doScroll ? e.setTimeout(w.ready) : (r.addEventListener('DOMContentLoaded', _), e.addEventListener('load', _)); var z = function (e, t, n, r, i, o, a) {
    let s = 0;
    const u = e.length;
    let l = n == null; if (x(n) === 'object') { i = !0; for (s in n) z(e, t, s, n[s], !0, o, a); } else if (void 0 !== r && (i = !0, g(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) { return l.call(w(e), n); })), t)) for (; s < u; s++) t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n))); return i ? e : l ? t.call(e) : u ? t(e[0], n) : o;
  };
  const X = /^-ms-/;
  const U = /-([a-z])/g;

  function V(e, t) { return t.toUpperCase(); }

  function G(e) { return e.replace(X, 'ms-').replace(U, V); } const Y = function (e) { return e.nodeType === 1 || e.nodeType === 9 || !+e.nodeType; };

  function Q() { this.expando = w.expando + Q.uid++; }
  Q.uid = 1, Q.prototype = {
    cache(e) { let t = e[this.expando]; return t || (t = {}, Y(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t; },
    set(e, t, n) {
      let r; const
        i = this.cache(e); if (typeof t === 'string') i[G(t)] = n;
      else for (r in t) i[G(r)] = t[r]; return i;
    },
    get(e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][G(t)]; },
    access(e, t, n) { return void 0 === t || t && typeof t === 'string' && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t); },
    remove(e, t) {
      let n; const
        r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(G) : (t = G(t)) in r ? [t] : t.match(M) || []).length; while (n--) delete r[t[n]]; }(void 0 === t || w.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]); }
    },
    hasData(e) { const t = e[this.expando]; return void 0 !== t && !w.isEmptyObject(t); },
  }; const J = new Q();
  const K = new Q();
  const Z = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/;
  const ee = /[A-Z]/g;

  function te(e) { return e === 'true' || e !== 'false' && (e === 'null' ? null : e === `${+e}` ? +e : Z.test(e) ? JSON.parse(e) : e); }

  function ne(e, t, n) {
    let r; if (void 0 === n && e.nodeType === 1) {
      if (r = `data-${t.replace(ee, '-$&').toLowerCase()}`, typeof (n = e.getAttribute(r)) === 'string') {
        try { n = te(n); } catch (e) {}
        K.set(e, t, n);
      } else n = void 0;
    }
    return n;
  }
  w.extend({
    hasData(e) { return K.hasData(e) || J.hasData(e); }, data(e, t, n) { return K.access(e, t, n); }, removeData(e, t) { K.remove(e, t); }, _data(e, t, n) { return J.access(e, t, n); }, _removeData(e, t) { J.remove(e, t); },
  }), w.fn.extend({
    data(e, t) {
      let n; let r; let i; const o = this[0];
      const a = o && o.attributes; if (void 0 === e) {
        if (this.length && (i = K.get(o), o.nodeType === 1 && !J.get(o, 'hasDataAttrs'))) {
          n = a.length; while (n--) a[n] && (r = a[n].name).indexOf('data-') === 0 && (r = G(r.slice(5)), ne(o, r, i[r]));
          J.set(o, 'hasDataAttrs', !0);
        } return i;
      } return typeof e === 'object' ? this.each(function () { K.set(this, e); }) : z(this, function (t) { let n; if (o && void 0 === t) { if (void 0 !== (n = K.get(o, e))) return n; if (void 0 !== (n = ne(o, e))) return n; } else this.each(function () { K.set(this, e, t); }); }, null, t, arguments.length > 1, null, !0);
    },
    removeData(e) { return this.each(function () { K.remove(this, e); }); },
  }), w.extend({
    queue(e, t, n) { let r; if (e) return t = `${t || 'fx'}queue`, r = J.get(e, t), n && (!r || Array.isArray(n) ? r = J.access(e, t, w.makeArray(n)) : r.push(n)), r || []; },
    dequeue(e, t) {
      t = t || 'fx'; const n = w.queue(e, t);
      let r = n.length;
      let i = n.shift();
      const o = w._queueHooks(e, t);
      const a = function () { w.dequeue(e, t); }; i === 'inprogress' && (i = n.shift(), r--), i && (t === 'fx' && n.unshift('inprogress'), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire();
    },
    _queueHooks(e, t) { const n = `${t}queueHooks`; return J.get(e, n) || J.access(e, n, { empty: w.Callbacks('once memory').add(() => { J.remove(e, [`${t}queue`, n]); }) }); },
  }), w.fn.extend({
    queue(e, t) {
      let n = 2; return typeof e !== 'string' && (t = e, e = 'fx', n--), arguments.length < n ? w.queue(this[0], e) : void 0 === t ? this : this.each(function () {
        const n = w.queue(this, e, t);
        w._queueHooks(this, e), e === 'fx' && n[0] !== 'inprogress' && w.dequeue(this, e);
      });
    },
    dequeue(e) { return this.each(function () { w.dequeue(this, e); }); },
    clearQueue(e) { return this.queue(e || 'fx', []); },
    promise(e, t) {
      let n; let r = 1;
      const i = w.Deferred();
      const o = this;
      let a = this.length;
      const s = function () { --r || i.resolveWith(o, [o]); }; typeof e !== 'string' && (t = e, e = void 0), e = e || 'fx'; while (a--)(n = J.get(o[a], `${e}queueHooks`)) && n.empty && (r++, n.empty.add(s)); return s(), i.promise(t);
    },
  }); const re = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  const ie = new RegExp(`^(?:([+-])=|)(${re})([a-z%]*)$`, 'i');
  const oe = ['Top', 'Right', 'Bottom', 'Left'];
  const ae = function (e, t) { return (e = t || e).style.display === 'none' || e.style.display === '' && w.contains(e.ownerDocument, e) && w.css(e, 'display') === 'none'; };
  const se = function (e, t, n, r) {
    let i; let o; const
      a = {}; for (o in t) a[o] = e.style[o], e.style[o] = t[o];
    i = n.apply(e, r || []); for (o in t) e.style[o] = a[o]; return i;
  };

  function ue(e, t, n, r) {
    let i; let o; let a = 20;
    const s = r ? function () { return r.cur(); } : function () { return w.css(e, t, ''); };
    let u = s();
    let l = n && n[3] || (w.cssNumber[t] ? '' : 'px');
    let c = (w.cssNumber[t] || l !== 'px' && +u) && ie.exec(w.css(e, t)); if (c && c[3] !== l) {
      u /= 2, l = l || c[3], c = +u || 1; while (a--) w.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || 0.5)) <= 0 && (a = 0), c /= o;
      c *= 2, w.style(e, t, c + l), n = n || [];
    } return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i;
  } const le = {};

  function ce(e) {
    let t; const n = e.ownerDocument;
    const r = e.nodeName;
    let i = le[r]; return i || (t = n.body.appendChild(n.createElement(r)), i = w.css(t, 'display'), t.parentNode.removeChild(t), i === 'none' && (i = 'block'), le[r] = i, i);
  }

  function fe(e, t) { for (var n, r, i = [], o = 0, a = e.length; o < a; o++)(r = e[o]).style && (n = r.style.display, t ? (n === 'none' && (i[o] = J.get(r, 'display') || null, i[o] || (r.style.display = '')), r.style.display === '' && ae(r) && (i[o] = ce(r))) : n !== 'none' && (i[o] = 'none', J.set(r, 'display', n))); for (o = 0; o < a; o++) i[o] != null && (e[o].style.display = i[o]); return e; }
  w.fn.extend({ show() { return fe(this, !0); }, hide() { return fe(this); }, toggle(e) { return typeof e === 'boolean' ? e ? this.show() : this.hide() : this.each(function () { ae(this) ? w(this).show() : w(this).hide(); }); } }); const pe = /^(?:checkbox|radio)$/i;
  const de = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
  const he = /^$|^module$|\/(?:java|ecma)script/i;
  const ge = {
    option: [1, "<select multiple='multiple'>", '</select>'], thead: [1, '<table>', '</table>'], col: [2, '<table><colgroup>', '</colgroup></table>'], tr: [2, '<table><tbody>', '</tbody></table>'], td: [3, '<table><tbody><tr>', '</tr></tbody></table>'], _default: [0, '', ''],
  };
  ge.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td;

  function ye(e, t) { let n; return n = typeof e.getElementsByTagName !== 'undefined' ? e.getElementsByTagName(t || '*') : typeof e.querySelectorAll !== 'undefined' ? e.querySelectorAll(t || '*') : [], void 0 === t || t && N(e, t) ? w.merge([e], n) : n; }

  function ve(e, t) { for (let n = 0, r = e.length; n < r; n++) J.set(e[n], 'globalEval', !t || J.get(t[n], 'globalEval')); } const me = /<|&#?\w+;/;

  function xe(e, t, n, r, i) {
    for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++) {
      if ((o = e[d]) || o === 0) {
        if (x(o) === 'object') w.merge(p, o.nodeType ? [o] : o);
        else if (me.test(o)) {
          a = a || f.appendChild(t.createElement('div')), s = (de.exec(o) || ['', ''])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + w.htmlPrefilter(o) + u[2], c = u[0]; while (c--) a = a.lastChild;
          w.merge(p, a.childNodes), (a = f.firstChild).textContent = '';
        } else p.push(t.createTextNode(o));
      }
    }
    f.textContent = '', d = 0; while (o = p[d++]) {
      if (r && w.inArray(o, r) > -1) i && i.push(o);
      else if (l = w.contains(o.ownerDocument, o), a = ye(f.appendChild(o), 'script'), l && ve(a), n) { c = 0; while (o = a[c++]) he.test(o.type || '') && n.push(o); }
    } return f;
  }!(function () {
    const e = r.createDocumentFragment().appendChild(r.createElement('div'));
    const t = r.createElement('input');
    t.setAttribute('type', 'radio'), t.setAttribute('checked', 'checked'), t.setAttribute('name', 't'), e.appendChild(t), h.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, e.innerHTML = '<textarea>x</textarea>', h.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue;
  }()); const be = r.documentElement;
  const we = /^key/;
  const Te = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
  const Ce = /^([^.]*)(?:\.(.+)|)/;

  function Ee() { return !0; }

  function ke() { return !1; }

  function Se() { try { return r.activeElement; } catch (e) {} }

  function De(e, t, n, r, i, o) {
    let a; let
      s; if (typeof t === 'object') { typeof n !== 'string' && (r = r || n, n = void 0); for (s in t) De(e, s, n, r, t[s], o); return e; } if (r == null && i == null ? (i = n, r = n = void 0) : i == null && (typeof n === 'string' ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = ke;
    else if (!i) return e; return o === 1 && (a = i, (i = function (e) { return w().off(e), a.apply(this, arguments); }).guid = a.guid || (a.guid = w.guid++)), e.each(function () { w.event.add(this, t, i, r, n); });
  }
  w.event = {
    global: {},
    add(e, t, n, r, i) {
      let o; let a; let s; let u; let l; let c; let f; let p; let d; let h; let g; const
        y = J.get(e); if (y) {
        n.handler && (n = (o = n).handler, i = o.selector), i && w.find.matchesSelector(be, i), n.guid || (n.guid = w.guid++), (u = y.events) || (u = y.events = {}), (a = y.handle) || (a = y.handle = function (t) { return typeof w !== 'undefined' && w.event.triggered !== t.type ? w.event.dispatch.apply(e, arguments) : void 0; }), l = (t = (t || '').match(M) || ['']).length; while (l--) {
          d = g = (s = Ce.exec(t[l]) || [])[1], h = (s[2] || '').split('.').sort(), d && (f = w.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = w.event.special[d] || {}, c = w.extend({
            type: d, origType: g, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && w.expr.match.needsContext.test(i), namespace: h.join('.'),
          }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(e, r, h, a) || e.addEventListener && e.addEventListener(d, a)), f.add && (f.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), w.event.global[d] = !0);
        }
      }
    },
    remove(e, t, n, r, i) {
      let o; let a; let s; let u; let l; let c; let f; let p; let d; let h; let g; const
        y = J.hasData(e) && J.get(e); if (y && (u = y.events)) {
        l = (t = (t || '').match(M) || ['']).length; while (l--) {
          if (s = Ce.exec(t[l]) || [], d = g = s[1], h = (s[2] || '').split('.').sort(), d) {
            f = w.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp(`(^|\\.)${h.join('\\.(?:.*\\.|)')}(\\.|$)`), a = o = p.length; while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && (r !== '**' || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));
            a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, y.handle) || w.removeEvent(e, d, y.handle), delete u[d]);
          } else for (d in u) w.event.remove(e, d + t[l], n, r, !0);
        }
        w.isEmptyObject(u) && J.remove(e, 'handle events');
      }
    },
    dispatch(e) {
      const t = w.event.fix(e);
      let n; let r; let i; let o; let a; let s; const u = new Array(arguments.length);
      const l = (J.get(this, 'events') || {})[t.type] || [];
      const c = w.event.special[t.type] || {}; for (u[0] = t, n = 1; n < arguments.length; n++) u[n] = arguments[n]; if (t.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, t)) { s = w.event.handlers.call(this, t, l), n = 0; while ((o = s[n++]) && !t.isPropagationStopped()) { t.currentTarget = o.elem, r = 0; while ((a = o.handlers[r++]) && !t.isImmediatePropagationStopped()) t.rnamespace && !t.rnamespace.test(a.namespace) || (t.handleObj = a, t.data = a.data, void 0 !== (i = ((w.event.special[a.origType] || {}).handle || a.handler).apply(o.elem, u)) && !1 === (t.result = i) && (t.preventDefault(), t.stopPropagation())); } return c.postDispatch && c.postDispatch.call(this, t), t.result; }
    },
    handlers(e, t) {
      let n; let r; let i; let o; let a; const s = [];
      const u = t.delegateCount;
      let l = e.target; if (u && l.nodeType && !(e.type === 'click' && e.button >= 1)) {
        for (; l !== this; l = l.parentNode || this) {
          if (l.nodeType === 1 && (e.type !== 'click' || !0 !== l.disabled)) {
            for (o = [], a = {}, n = 0; n < u; n++) void 0 === a[i = `${(r = t[n]).selector} `] && (a[i] = r.needsContext ? w(i, this).index(l) > -1 : w.find(i, this, null, [l]).length), a[i] && o.push(r);
            o.length && s.push({ elem: l, handlers: o });
          }
        }
      }
      return l = this, u < t.length && s.push({ elem: l, handlers: t.slice(u) }), s;
    },
    addProp(e, t) {
      Object.defineProperty(w.Event.prototype, e, {
        enumerable: !0,
        configurable: !0,
        get: g(t) ? function () { if (this.originalEvent) return t(this.originalEvent); } : function () { if (this.originalEvent) return this.originalEvent[e]; },
        set(t) {
          Object.defineProperty(this, e, {
            enumerable: !0, configurable: !0, writable: !0, value: t,
          });
        },
      });
    },
    fix(e) { return e[w.expando] ? e : new w.Event(e); },
    special: {
      load: { noBubble: !0 }, focus: { trigger() { if (this !== Se() && this.focus) return this.focus(), !1; }, delegateType: 'focusin' }, blur: { trigger() { if (this === Se() && this.blur) return this.blur(), !1; }, delegateType: 'focusout' }, click: { trigger() { if (this.type === 'checkbox' && this.click && N(this, 'input')) return this.click(), !1; }, _default(e) { return N(e.target, 'a'); } }, beforeunload: { postDispatch(e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result); } },
    },
  }, w.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n); }, w.Event = function (e, t) {
    if (!(this instanceof w.Event)) return new w.Event(e, t);
    e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Ee : ke, this.target = e.target && e.target.nodeType === 3 ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && w.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[w.expando] = !0;
  }, w.Event.prototype = {
    constructor: w.Event,
    isDefaultPrevented: ke,
    isPropagationStopped: ke,
    isImmediatePropagationStopped: ke,
    isSimulated: !1,
    preventDefault() {
      const e = this.originalEvent;
      this.isDefaultPrevented = Ee, e && !this.isSimulated && e.preventDefault();
    },
    stopPropagation() {
      const e = this.originalEvent;
      this.isPropagationStopped = Ee, e && !this.isSimulated && e.stopPropagation();
    },
    stopImmediatePropagation() {
      const e = this.originalEvent;
      this.isImmediatePropagationStopped = Ee, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation();
    },
  }, w.each({
    altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, char: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which(e) { const t = e.button; return e.which == null && we.test(e.type) ? e.charCode != null ? e.charCode : e.keyCode : !e.which && void 0 !== t && Te.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which; },
  }, w.event.addProp), w.each({
    mouseenter: 'mouseover', mouseleave: 'mouseout', pointerenter: 'pointerover', pointerleave: 'pointerout',
  }, (e, t) => {
    w.event.special[e] = {
      delegateType: t,
      bindType: t,
      handle(e) {
        let n; const r = this;
        const i = e.relatedTarget;
        const o = e.handleObj; return i && (i === r || w.contains(r, i)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n;
      },
    };
  }), w.fn.extend({
    on(e, t, n, r) { return De(this, e, t, n, r); },
    one(e, t, n, r) { return De(this, e, t, n, r, 1); },
    off(e, t, n) {
      let r; let
        i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, w(e.delegateTarget).off(r.namespace ? `${r.origType}.${r.namespace}` : r.origType, r.selector, r.handler), this; if (typeof e === 'object') { for (i in e) this.off(i, t, e[i]); return this; } return !1 !== t && typeof t !== 'function' || (n = t, t = void 0), !1 === n && (n = ke), this.each(function () { w.event.remove(this, e, n, t); });
    },
  }); const Ne = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi;
  const Ae = /<script|<style|<link/i;
  const je = /checked\s*(?:[^=]|=\s*.checked.)/i;
  const qe = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

  function Le(e, t) { return N(e, 'table') && N(t.nodeType !== 11 ? t : t.firstChild, 'tr') ? w(e).children('tbody')[0] || e : e; }

  function He(e) { return e.type = `${e.getAttribute('type') !== null}/${e.type}`, e; }

  function Oe(e) { return (e.type || '').slice(0, 5) === 'true/' ? e.type = e.type.slice(5) : e.removeAttribute('type'), e; }

  function Pe(e, t) {
    let n; let r; let i; let o; let a; let s; let u; let
      l; if (t.nodeType === 1) {
      if (J.hasData(e) && (o = J.access(e), a = J.set(t, o), l = o.events)) {
        delete a.handle, a.events = {}; for (i in l) for (n = 0, r = l[i].length; n < r; n++) w.event.add(t, i, l[i][n]);
      }
      K.hasData(e) && (s = K.access(e), u = w.extend({}, s), K.set(t, u));
    }
  }

  function Me(e, t) { const n = t.nodeName.toLowerCase(); n === 'input' && pe.test(e.type) ? t.checked = e.checked : n !== 'input' && n !== 'textarea' || (t.defaultValue = e.defaultValue); }

  function Re(e, t, n, r) {
    t = a.apply([], t); let i; let o; let s; let u; let l; let c; let f = 0;
    const p = e.length;
    const d = p - 1;
    const y = t[0];
    const v = g(y); if (v || p > 1 && typeof y === 'string' && !h.checkClone && je.test(y)) {
      return e.each(function (i) {
        const o = e.eq(i);
        v && (t[0] = y.call(this, i, o.html())), Re(o, t, n, r);
      });
    } if (p && (i = xe(t, e[0].ownerDocument, !1, e, r), o = i.firstChild, i.childNodes.length === 1 && (i = o), o || r)) {
      for (u = (s = w.map(ye(i, 'script'), He)).length; f < p; f++) l = i, f !== d && (l = w.clone(l, !0, !0), u && w.merge(s, ye(l, 'script'))), n.call(e[f], l, f); if (u) for (c = s[s.length - 1].ownerDocument, w.map(s, Oe), f = 0; f < u; f++) l = s[f], he.test(l.type || '') && !J.access(l, 'globalEval') && w.contains(c, l) && (l.src && (l.type || '').toLowerCase() !== 'module' ? w._evalUrl && w._evalUrl(l.src) : m(l.textContent.replace(qe, ''), c, l));
    } return e;
  }

  function Ie(e, t, n) { for (var r, i = t ? w.filter(t, e) : e, o = 0; (r = i[o]) != null; o++) n || r.nodeType !== 1 || w.cleanData(ye(r)), r.parentNode && (n && w.contains(r.ownerDocument, r) && ve(ye(r, 'script')), r.parentNode.removeChild(r)); return e; }
  w.extend({
    htmlPrefilter(e) { return e.replace(Ne, '<$1></$2>'); },
    clone(e, t, n) {
      let r; let i; let o; let a; const s = e.cloneNode(!0);
      const u = w.contains(e.ownerDocument, e); if (!(h.noCloneChecked || e.nodeType !== 1 && e.nodeType !== 11 || w.isXMLDoc(e))) for (a = ye(s), r = 0, i = (o = ye(e)).length; r < i; r++) Me(o[r], a[r]); if (t) {
        if (n) for (o = o || ye(e), a = a || ye(s), r = 0, i = o.length; r < i; r++) Pe(o[r], a[r]);
        else Pe(e, s);
      }
      return (a = ye(s, 'script')).length > 0 && ve(a, !u && ye(e, 'script')), s;
    },
    cleanData(e) {
      for (var t, n, r, i = w.event.special, o = 0; void 0 !== (n = e[o]); o++) {
        if (Y(n)) {
          if (t = n[J.expando]) {
            if (t.events) for (r in t.events) i[r] ? w.event.remove(n, r) : w.removeEvent(n, r, t.handle);
            n[J.expando] = void 0;
          }
          n[K.expando] && (n[K.expando] = void 0);
        }
      }
    },
  }), w.fn.extend({
    detach(e) { return Ie(this, e, !0); },
    remove(e) { return Ie(this, e); },
    text(e) { return z(this, function (e) { return void 0 === e ? w.text(this) : this.empty().each(function () { this.nodeType !== 1 && this.nodeType !== 11 && this.nodeType !== 9 || (this.textContent = e); }); }, null, e, arguments.length); },
    append() { return Re(this, arguments, function (e) { this.nodeType !== 1 && this.nodeType !== 11 && this.nodeType !== 9 || Le(this, e).appendChild(e); }); },
    prepend() {
      return Re(this, arguments, function (e) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          const t = Le(this, e);
          t.insertBefore(e, t.firstChild);
        }
      });
    },
    before() { return Re(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this); }); },
    after() { return Re(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling); }); },
    empty() { for (var e, t = 0; (e = this[t]) != null; t++) e.nodeType === 1 && (w.cleanData(ye(e, !1)), e.textContent = ''); return this; },
    clone(e, t) { return e = e != null && e, t = t == null ? e : t, this.map(function () { return w.clone(this, e, t); }); },
    html(e) {
      return z(this, function (e) {
        let t = this[0] || {};
        let n = 0;
        const r = this.length; if (void 0 === e && t.nodeType === 1) return t.innerHTML; if (typeof e === 'string' && !Ae.test(e) && !ge[(de.exec(e) || ['', ''])[1].toLowerCase()]) {
          e = w.htmlPrefilter(e); try {
            for (; n < r; n++) (t = this[n] || {}).nodeType === 1 && (w.cleanData(ye(t, !1)), t.innerHTML = e);
            t = 0;
          } catch (e) {}
        }
        t && this.empty().append(e);
      }, null, e, arguments.length);
    },
    replaceWith() {
      const e = []; return Re(this, arguments, function (t) {
        const n = this.parentNode;
        w.inArray(this, e) < 0 && (w.cleanData(ye(this)), n && n.replaceChild(t, this));
      }, e);
    },
  }), w.each({
    appendTo: 'append', prependTo: 'prepend', insertBefore: 'before', insertAfter: 'after', replaceAll: 'replaceWith',
  }, (e, t) => { w.fn[e] = function (e) { for (var n, r = [], i = w(e), o = i.length - 1, a = 0; a <= o; a++) n = a === o ? this : this.clone(!0), w(i[a])[t](n), s.apply(r, n.get()); return this.pushStack(r); }; }); const We = new RegExp(`^(${re})(?!px)[a-z%]+$`, 'i');
  const $e = function (t) { let n = t.ownerDocument.defaultView; return n && n.opener || (n = e), n.getComputedStyle(t); };
  const Be = new RegExp(oe.join('|'), 'i'); !(function () {
    function t() {
      if (c) {
        l.style.cssText = 'position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0', c.style.cssText = 'position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%', be.appendChild(l).appendChild(c); const t = e.getComputedStyle(c);
        i = t.top !== '1%', u = n(t.marginLeft) === 12, c.style.right = '60%', s = n(t.right) === 36, o = n(t.width) === 36, c.style.position = 'absolute', a = c.offsetWidth === 36 || 'absolute', be.removeChild(l), c = null;
      }
    }

    function n(e) { return Math.round(parseFloat(e)); } let i; let o; let a; let s; let u; var l = r.createElement('div');
    var c = r.createElement('div');
    c.style && (c.style.backgroundClip = 'content-box', c.cloneNode(!0).style.backgroundClip = '', h.clearCloneStyle = c.style.backgroundClip === 'content-box', w.extend(h, {
      boxSizingReliable() { return t(), o; }, pixelBoxStyles() { return t(), s; }, pixelPosition() { return t(), i; }, reliableMarginLeft() { return t(), u; }, scrollboxSize() { return t(), a; },
    }));
  }());

  function Fe(e, t, n) {
    let r; let i; let o; let a; const
      s = e.style; return (n = n || $e(e)) && ((a = n.getPropertyValue(t) || n[t]) !== '' || w.contains(e.ownerDocument, e) || (a = w.style(e, t)), !h.pixelBoxStyles() && We.test(a) && Be.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? `${a}` : a;
  }

  function _e(e, t) {
    return {
      get() {
        if (!e()) return (this.get = t).apply(this, arguments);
        delete this.get;
      },
    };
  } const ze = /^(none|table(?!-c[ea]).+)/;
  const Xe = /^--/;
  const Ue = { position: 'absolute', visibility: 'hidden', display: 'block' };
  const Ve = { letterSpacing: '0', fontWeight: '400' };
  const Ge = ['Webkit', 'Moz', 'ms'];
  const Ye = r.createElement('div').style;

  function Qe(e) {
    if (e in Ye) return e; const t = e[0].toUpperCase() + e.slice(1);
    let n = Ge.length; while (n--) if ((e = Ge[n] + t) in Ye) return e;
  }

  function Je(e) { let t = w.cssProps[e]; return t || (t = w.cssProps[e] = Qe(e) || e), t; }

  function Ke(e, t, n) { const r = ie.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || 'px') : t; }

  function Ze(e, t, n, r, i, o) {
    let a = t === 'width' ? 1 : 0;
    let s = 0;
    let u = 0; if (n === (r ? 'border' : 'content')) return 0; for (; a < 4; a += 2) n === 'margin' && (u += w.css(e, n + oe[a], !0, i)), r ? (n === 'content' && (u -= w.css(e, `padding${oe[a]}`, !0, i)), n !== 'margin' && (u -= w.css(e, `border${oe[a]}Width`, !0, i))) : (u += w.css(e, `padding${oe[a]}`, !0, i), n !== 'padding' ? u += w.css(e, `border${oe[a]}Width`, !0, i) : s += w.css(e, `border${oe[a]}Width`, !0, i)); return !r && o >= 0 && (u += Math.max(0, Math.ceil(e[`offset${t[0].toUpperCase()}${t.slice(1)}`] - o - u - s - 0.5))), u;
  }

  function et(e, t, n) {
    const r = $e(e);
    let i = Fe(e, t, r);
    const o = w.css(e, 'boxSizing', !1, r) === 'border-box';
    let a = o; if (We.test(i)) {
      if (!n) return i;
      i = 'auto';
    } return a = a && (h.boxSizingReliable() || i === e.style[t]), (i === 'auto' || !parseFloat(i) && w.css(e, 'display', !1, r) === 'inline') && (i = e[`offset${t[0].toUpperCase()}${t.slice(1)}`], a = !0), `${(i = parseFloat(i) || 0) + Ze(e, t, n || (o ? 'border' : 'content'), a, r, i)}px`;
  }
  w.extend({
    cssHooks: { opacity: { get(e, t) { if (t) { const n = Fe(e, 'opacity'); return n === '' ? '1' : n; } } } },
    cssNumber: {
      animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0,
    },
    cssProps: {},
    style(e, t, n, r) {
      if (e && e.nodeType !== 3 && e.nodeType !== 8 && e.style) {
        let i; let o; let a; const s = G(t);
        const u = Xe.test(t);
        const l = e.style; if (u || (t = Je(s)), a = w.cssHooks[t] || w.cssHooks[s], void 0 === n) return a && 'get' in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t]; (o = typeof n) == 'string' && (i = ie.exec(n)) && i[1] && (n = ue(e, t, i), o = 'number'), n != null && n === n && (o === 'number' && (n += i && i[3] || (w.cssNumber[s] ? '' : 'px')), h.clearCloneStyle || n !== '' || t.indexOf('background') !== 0 || (l[t] = 'inherit'), a && 'set' in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n));
      }
    },
    css(e, t, n, r) {
      let i; let o; let a; const
        s = G(t); return Xe.test(t) || (t = Je(s)), (a = w.cssHooks[t] || w.cssHooks[s]) && 'get' in a && (i = a.get(e, !0, n)), void 0 === i && (i = Fe(e, t, r)), i === 'normal' && t in Ve && (i = Ve[t]), n === '' || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i;
    },
  }), w.each(['height', 'width'], (e, t) => {
    w.cssHooks[t] = {
      get(e, n, r) { if (n) return !ze.test(w.css(e, 'display')) || e.getClientRects().length && e.getBoundingClientRect().width ? et(e, t, r) : se(e, Ue, () => et(e, t, r)); },
      set(e, n, r) {
        let i; const o = $e(e);
        const a = w.css(e, 'boxSizing', !1, o) === 'border-box';
        let s = r && Ze(e, t, r, a, o); return a && h.scrollboxSize() === o.position && (s -= Math.ceil(e[`offset${t[0].toUpperCase()}${t.slice(1)}`] - parseFloat(o[t]) - Ze(e, t, 'border', !1, o) - 0.5)), s && (i = ie.exec(n)) && (i[3] || 'px') !== 'px' && (e.style[t] = n, n = w.css(e, t)), Ke(e, n, s);
      },
    };
  }), w.cssHooks.marginLeft = _e(h.reliableMarginLeft, (e, t) => { if (t) return `${parseFloat(Fe(e, 'marginLeft')) || e.getBoundingClientRect().left - se(e, { marginLeft: 0 }, () => e.getBoundingClientRect().left)}px`; }), w.each({ margin: '', padding: '', border: 'Width' }, (e, t) => { w.cssHooks[e + t] = { expand(n) { for (var r = 0, i = {}, o = typeof n === 'string' ? n.split(' ') : [n]; r < 4; r++) i[e + oe[r] + t] = o[r] || o[r - 2] || o[0]; return i; } }, e !== 'margin' && (w.cssHooks[e + t].set = Ke); }), w.fn.extend({
    css(e, t) {
      return z(this, (e, t, n) => {
        let r; let i; const o = {};
        let a = 0; if (Array.isArray(t)) { for (r = $e(e), i = t.length; a < i; a++) o[t[a]] = w.css(e, t[a], !1, r); return o; } return void 0 !== n ? w.style(e, t, n) : w.css(e, t);
      }, e, t, arguments.length > 1);
    },
  });

  function tt(e, t, n, r, i) { return new tt.prototype.init(e, t, n, r, i); }
  w.Tween = tt, tt.prototype = {
    constructor: tt,
    init(e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || w.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (w.cssNumber[n] ? '' : 'px'); },
    cur() { const e = tt.propHooks[this.prop]; return e && e.get ? e.get(this) : tt.propHooks._default.get(this); },
    run(e) {
      let t; const
        n = tt.propHooks[this.prop]; return this.options.duration ? this.pos = t = w.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : tt.propHooks._default.set(this), this;
    },
  }, tt.prototype.init.prototype = tt.prototype, tt.propHooks = { _default: { get(e) { let t; return e.elem.nodeType !== 1 || e.elem[e.prop] != null && e.elem.style[e.prop] == null ? e.elem[e.prop] : (t = w.css(e.elem, e.prop, '')) && t !== 'auto' ? t : 0; }, set(e) { w.fx.step[e.prop] ? w.fx.step[e.prop](e) : e.elem.nodeType !== 1 || e.elem.style[w.cssProps[e.prop]] == null && !w.cssHooks[e.prop] ? e.elem[e.prop] = e.now : w.style(e.elem, e.prop, e.now + e.unit); } } }, tt.propHooks.scrollTop = tt.propHooks.scrollLeft = { set(e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now); } }, w.easing = { linear(e) { return e; }, swing(e) { return 0.5 - Math.cos(e * Math.PI) / 2; }, _default: 'swing' }, w.fx = tt.prototype.init, w.fx.step = {}; let nt; let rt; const it = /^(?:toggle|show|hide)$/;
  const ot = /queueHooks$/;

  function at() { rt && (!1 === r.hidden && e.requestAnimationFrame ? e.requestAnimationFrame(at) : e.setTimeout(at, w.fx.interval), w.fx.tick()); }

  function st() { return e.setTimeout(() => { nt = void 0; }), nt = Date.now(); }

  function ut(e, t) {
    let n; let r = 0;
    const i = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t) i[`margin${n = oe[r]}`] = i[`padding${n}`] = e; return t && (i.opacity = i.width = e), i;
  }

  function lt(e, t, n) {
    for (var r, i = (pt.tweeners[t] || []).concat(pt.tweeners['*']), o = 0, a = i.length; o < a; o++) if (r = i[o].call(n, t, e)) return r;
  }

  function ct(e, t, n) {
    let r; let i; let o; let a; let s; let u; let l; let c; const f = 'width' in t || 'height' in t;
    const p = this;
    const d = {};
    const h = e.style;
    let g = e.nodeType && ae(e);
    let y = J.get(e, 'fxshow');
    n.queue || ((a = w._queueHooks(e, 'fx')).unqueued == null && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () { a.unqueued || s(); }), a.unqueued++, p.always(() => { p.always(() => { a.unqueued--, w.queue(e, 'fx').length || a.empty.fire(); }); })); for (r in t) {
      if (i = t[r], it.test(i)) {
        if (delete t[r], o = o || i === 'toggle', i === (g ? 'hide' : 'show')) {
          if (i !== 'show' || !y || void 0 === y[r]) continue;
          g = !0;
        }
        d[r] = y && y[r] || w.style(e, r);
      }
    }
    if ((u = !w.isEmptyObject(t)) || !w.isEmptyObject(d)) { f && e.nodeType === 1 && (n.overflow = [h.overflow, h.overflowX, h.overflowY], (l = y && y.display) == null && (l = J.get(e, 'display')), (c = w.css(e, 'display')) === 'none' && (l ? c = l : (fe([e], !0), l = e.style.display || l, c = w.css(e, 'display'), fe([e]))), (c === 'inline' || c === 'inline-block' && l != null) && w.css(e, 'float') === 'none' && (u || (p.done(() => { h.display = l; }), l == null && (c = h.display, l = c === 'none' ? '' : c)), h.display = 'inline-block')), n.overflow && (h.overflow = 'hidden', p.always(() => { h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2]; })), u = !1; for (r in d) u || (y ? 'hidden' in y && (g = y.hidden) : y = J.access(e, 'fxshow', { display: l }), o && (y.hidden = !g), g && fe([e], !0), p.done(() => { g || fe([e]), J.remove(e, 'fxshow'); for (r in d) w.style(e, r, d[r]); })), u = lt(g ? y[r] : 0, r, p), r in y || (y[r] = u.start, g && (u.end = u.start, u.start = 0)); }
  }

  function ft(e, t) {
    let n; let r; let i; let o; let
      a; for (n in e) if (r = G(n), i = t[r], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = w.cssHooks[r]) && 'expand' in a) { o = a.expand(o), delete e[r]; for (n in o) n in e || (e[n] = o[n], t[n] = i); } else t[r] = i;
  }

  function pt(e, t, n) {
    let r; let i; let o = 0;
    const a = pt.prefilters.length;
    const s = w.Deferred().always(() => { delete u.elem; });
    var u = function () { if (i) return !1; for (var t = nt || st(), n = Math.max(0, l.startTime + l.duration - t), r = 1 - (n / l.duration || 0), o = 0, a = l.tweens.length; o < a; o++) l.tweens[o].run(r); return s.notifyWith(e, [l, r, n]), r < 1 && a ? n : (a || s.notifyWith(e, [l, 1, 0]), s.resolveWith(e, [l]), !1); };
    var l = s.promise({
      elem: e,
      props: w.extend({}, t),
      opts: w.extend(!0, { specialEasing: {}, easing: w.easing._default }, n),
      originalProperties: t,
      originalOptions: n,
      startTime: nt || st(),
      duration: n.duration,
      tweens: [],
      createTween(t, n) { const r = w.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing); return l.tweens.push(r), r; },
      stop(t) {
        let n = 0;
        const r = t ? l.tweens.length : 0; if (i) return this; for (i = !0; n < r; n++) l.tweens[n].run(1); return t ? (s.notifyWith(e, [l, 1, 0]), s.resolveWith(e, [l, t])) : s.rejectWith(e, [l, t]), this;
      },
    });
    const c = l.props; for (ft(c, l.opts.specialEasing); o < a; o++) if (r = pt.prefilters[o].call(l, e, c, l.opts)) return g(r.stop) && (w._queueHooks(l.elem, l.opts.queue).stop = r.stop.bind(r)), r;
    return w.map(c, lt, l), g(l.opts.start) && l.opts.start.call(e, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), w.fx.timer(w.extend(u, { elem: e, anim: l, queue: l.opts.queue })), l;
  }
  w.Animation = w.extend(pt, {
    tweeners: { '*': [function (e, t) { const n = this.createTween(e, t); return ue(n.elem, e, ie.exec(t), n), n; }] }, tweener(e, t) { g(e) ? (t = e, e = ['*']) : e = e.match(M); for (var n, r = 0, i = e.length; r < i; r++) n = e[r], pt.tweeners[n] = pt.tweeners[n] || [], pt.tweeners[n].unshift(t); }, prefilters: [ct], prefilter(e, t) { t ? pt.prefilters.unshift(e) : pt.prefilters.push(e); },
  }), w.speed = function (e, t, n) { const r = e && typeof e === 'object' ? w.extend({}, e) : { complete: n || !n && t || g(e) && e, duration: e, easing: n && t || t && !g(t) && t }; return w.fx.off ? r.duration = 0 : typeof r.duration !== 'number' && (r.duration in w.fx.speeds ? r.duration = w.fx.speeds[r.duration] : r.duration = w.fx.speeds._default), r.queue != null && !0 !== r.queue || (r.queue = 'fx'), r.old = r.complete, r.complete = function () { g(r.old) && r.old.call(this), r.queue && w.dequeue(this, r.queue); }, r; }, w.fn.extend({
    fadeTo(e, t, n, r) {
      return this.filter(ae).css('opacity', 0).show().end()
        .animate({ opacity: t }, e, n, r);
    },
    animate(e, t, n, r) {
      const i = w.isEmptyObject(e);
      const o = w.speed(t, n, r);
      const a = function () {
        const t = pt(this, w.extend({}, e), o);
        (i || J.get(this, 'finish')) && t.stop(!0);
      }; return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a);
    },
    stop(e, t, n) {
      const r = function (e) {
        const t = e.stop;
        delete e.stop, t(n);
      }; return typeof e !== 'string' && (n = t, t = e, e = void 0), t && !1 !== e && this.queue(e || 'fx', []), this.each(function () {
        let t = !0;
        let i = e != null && `${e}queueHooks`;
        const o = w.timers;
        const a = J.get(this); if (i) a[i] && a[i].stop && r(a[i]);
        else for (i in a) a[i] && a[i].stop && ot.test(i) && r(a[i]); for (i = o.length; i--;) o[i].elem !== this || e != null && o[i].queue !== e || (o[i].anim.stop(n), t = !1, o.splice(i, 1)); !t && n || w.dequeue(this, e);
      });
    },
    finish(e) {
      return !1 !== e && (e = e || 'fx'), this.each(function () {
        let t; const n = J.get(this);
        const r = n[`${e}queue`];
        const i = n[`${e}queueHooks`];
        const o = w.timers;
        const a = r ? r.length : 0; for (n.finish = !0, w.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1)); for (t = 0; t < a; t++) r[t] && r[t].finish && r[t].finish.call(this);
        delete n.finish;
      });
    },
  }), w.each(['toggle', 'show', 'hide'], (e, t) => {
    const n = w.fn[t];
    w.fn[t] = function (e, r, i) { return e == null || typeof e === 'boolean' ? n.apply(this, arguments) : this.animate(ut(t, !0), e, r, i); };
  }), w.each({
    slideDown: ut('show'), slideUp: ut('hide'), slideToggle: ut('toggle'), fadeIn: { opacity: 'show' }, fadeOut: { opacity: 'hide' }, fadeToggle: { opacity: 'toggle' },
  }, (e, t) => { w.fn[e] = function (e, n, r) { return this.animate(t, e, n, r); }; }), w.timers = [], w.fx.tick = function () {
    let e; let t = 0;
    const n = w.timers; for (nt = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1);
    n.length || w.fx.stop(), nt = void 0;
  }, w.fx.timer = function (e) { w.timers.push(e), w.fx.start(); }, w.fx.interval = 13, w.fx.start = function () { rt || (rt = !0, at()); }, w.fx.stop = function () { rt = null; }, w.fx.speeds = { slow: 600, fast: 200, _default: 400 }, w.fn.delay = function (t, n) {
    return t = w.fx ? w.fx.speeds[t] || t : t, n = n || 'fx', this.queue(n, (n, r) => {
      const i = e.setTimeout(n, t);
      r.stop = function () { e.clearTimeout(i); };
    });
  },
  (function () {
    let e = r.createElement('input');
    const t = r.createElement('select').appendChild(r.createElement('option'));
    e.type = 'checkbox', h.checkOn = e.value !== '', h.optSelected = t.selected, (e = r.createElement('input')).value = 't', e.type = 'radio', h.radioValue = e.value === 't';
  }()); let dt; const
    ht = w.expr.attrHandle;
  w.fn.extend({ attr(e, t) { return z(this, w.attr, e, t, arguments.length > 1); }, removeAttr(e) { return this.each(function () { w.removeAttr(this, e); }); } }), w.extend({
    attr(e, t, n) {
      let r; let i; const
        o = e.nodeType; if (o !== 3 && o !== 8 && o !== 2) return typeof e.getAttribute === 'undefined' ? w.prop(e, t, n) : (o === 1 && w.isXMLDoc(e) || (i = w.attrHooks[t.toLowerCase()] || (w.expr.match.bool.test(t) ? dt : void 0)), void 0 !== n ? n === null ? void w.removeAttr(e, t) : i && 'set' in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, `${n}`), n) : i && 'get' in i && (r = i.get(e, t)) !== null ? r : (r = w.find.attr(e, t)) == null ? void 0 : r);
    },
    attrHooks: { type: { set(e, t) { if (!h.radioValue && t === 'radio' && N(e, 'input')) { const n = e.value; return e.setAttribute('type', t), n && (e.value = n), t; } } } },
    removeAttr(e, t) {
      let n; let r = 0;
      const i = t && t.match(M); if (i && e.nodeType === 1) while (n = i[r++]) e.removeAttribute(n);
    },
  }), dt = { set(e, t, n) { return !1 === t ? w.removeAttr(e, n) : e.setAttribute(n, n), n; } }, w.each(w.expr.match.bool.source.match(/\w+/g), (e, t) => {
    const n = ht[t] || w.find.attr;
    ht[t] = function (e, t, r) {
      let i; let o; const
        a = t.toLowerCase(); return r || (o = ht[a], ht[a] = i, i = n(e, t, r) != null ? a : null, ht[a] = o), i;
    };
  }); const gt = /^(?:input|select|textarea|button)$/i;
  const yt = /^(?:a|area)$/i;
  w.fn.extend({ prop(e, t) { return z(this, w.prop, e, t, arguments.length > 1); }, removeProp(e) { return this.each(function () { delete this[w.propFix[e] || e]; }); } }), w.extend({
    prop(e, t, n) {
      let r; let i; const
        o = e.nodeType; if (o !== 3 && o !== 8 && o !== 2) return o === 1 && w.isXMLDoc(e) || (t = w.propFix[t] || t, i = w.propHooks[t]), void 0 !== n ? i && 'set' in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && 'get' in i && (r = i.get(e, t)) !== null ? r : e[t];
    },
    propHooks: { tabIndex: { get(e) { const t = w.find.attr(e, 'tabindex'); return t ? parseInt(t, 10) : gt.test(e.nodeName) || yt.test(e.nodeName) && e.href ? 0 : -1; } } },
    propFix: { for: 'htmlFor', class: 'className' },
  }), h.optSelected || (w.propHooks.selected = {
    get(e) { const t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null; },
    set(e) {
      const t = e.parentNode;
      t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex);
    },
  }), w.each(['tabIndex', 'readOnly', 'maxLength', 'cellSpacing', 'cellPadding', 'rowSpan', 'colSpan', 'useMap', 'frameBorder', 'contentEditable'], function () { w.propFix[this.toLowerCase()] = this; });

  function vt(e) { return (e.match(M) || []).join(' '); }

  function mt(e) { return e.getAttribute && e.getAttribute('class') || ''; }

  function xt(e) { return Array.isArray(e) ? e : typeof e === 'string' ? e.match(M) || [] : []; }
  w.fn.extend({
    addClass(e) {
      let t; let n; let r; let i; let o; let a; let s; let
        u = 0; if (g(e)) return this.each(function (t) { w(this).addClass(e.call(this, t, mt(this))); }); if ((t = xt(e)).length) {
        while (n = this[u++]) {
          if (i = mt(n), r = n.nodeType === 1 && ` ${vt(i)} `) {
            a = 0; while (o = t[a++]) r.indexOf(` ${o} `) < 0 && (r += `${o} `);
            i !== (s = vt(r)) && n.setAttribute('class', s);
          }
        }
      }
      return this;
    },
    removeClass(e) {
      let t; let n; let r; let i; let o; let a; let s; let
        u = 0; if (g(e)) return this.each(function (t) { w(this).removeClass(e.call(this, t, mt(this))); }); if (!arguments.length) return this.attr('class', ''); if ((t = xt(e)).length) {
        while (n = this[u++]) {
          if (i = mt(n), r = n.nodeType === 1 && ` ${vt(i)} `) {
            a = 0; while (o = t[a++]) while (r.indexOf(` ${o} `) > -1) r = r.replace(` ${o} `, ' ');
            i !== (s = vt(r)) && n.setAttribute('class', s);
          }
        }
      }
      return this;
    },
    toggleClass(e, t) {
      const n = typeof e;
      const r = n === 'string' || Array.isArray(e); return typeof t === 'boolean' && r ? t ? this.addClass(e) : this.removeClass(e) : g(e) ? this.each(function (n) { w(this).toggleClass(e.call(this, n, mt(this), t), t); }) : this.each(function () {
        let t; let i; let o; let
          a; if (r) { i = 0, o = w(this), a = xt(e); while (t = a[i++]) o.hasClass(t) ? o.removeClass(t) : o.addClass(t); } else void 0 !== e && n !== 'boolean' || ((t = mt(this)) && J.set(this, '__className__', t), this.setAttribute && this.setAttribute('class', t || !1 === e ? '' : J.get(this, '__className__') || ''));
      });
    },
    hasClass(e) {
      let t; let n; let
        r = 0;
      t = ` ${e} `; while (n = this[r++]) if (n.nodeType === 1 && (` ${vt(mt(n))} `).indexOf(t) > -1) return !0;
      return !1;
    },
  }); const bt = /\r/g;
  w.fn.extend({
    val(e) {
      let t; let n; let r; const
        i = this[0]; { if (arguments.length) {
        return r = g(e), this.each(function (n) {
          let i;
          this.nodeType === 1 && ((i = r ? e.call(this, n, w(this).val()) : e) == null ? i = '' : typeof i === 'number' ? i += '' : Array.isArray(i) && (i = w.map(i, (e) => (e == null ? '' : `${e}`))), (t = w.valHooks[this.type] || w.valHooks[this.nodeName.toLowerCase()]) && 'set' in t && void 0 !== t.set(this, i, 'value') || (this.value = i));
        });
      } if (i) return (t = w.valHooks[i.type] || w.valHooks[i.nodeName.toLowerCase()]) && 'get' in t && void 0 !== (n = t.get(i, 'value')) ? n : typeof (n = i.value) === 'string' ? n.replace(bt, '') : n == null ? '' : n; }
    },
  }), w.extend({
    valHooks: {
      option: { get(e) { const t = w.find.attr(e, 'value'); return t != null ? t : vt(w.text(e)); } },
      select: {
        get(e) {
          let t; let n; let r; const i = e.options;
          const o = e.selectedIndex;
          const a = e.type === 'select-one';
          const s = a ? null : [];
          const u = a ? o + 1 : i.length; for (r = o < 0 ? u : a ? o : 0; r < u; r++) {
            if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !N(n.parentNode, 'optgroup'))) {
              if (t = w(n).val(), a) return t;
              s.push(t);
            }
          }
          return s;
        },
        set(e, t) {
          let n; let r; const i = e.options;
          const o = w.makeArray(t);
          let a = i.length; while (a--)((r = i[a]).selected = w.inArray(w.valHooks.option.get(r), o) > -1) && (n = !0); return n || (e.selectedIndex = -1), o;
        },
      },
    },
  }), w.each(['radio', 'checkbox'], function () { w.valHooks[this] = { set(e, t) { if (Array.isArray(t)) return e.checked = w.inArray(w(e).val(), t) > -1; } }, h.checkOn || (w.valHooks[this].get = function (e) { return e.getAttribute('value') === null ? 'on' : e.value; }); }), h.focusin = 'onfocusin' in e; const wt = /^(?:focusinfocus|focusoutblur)$/;
  const Tt = function (e) { e.stopPropagation(); };
  w.extend(w.event, {
    trigger(t, n, i, o) {
      let a; let s; let u; let l; let c; let p; let d; let h; const v = [i || r];
      let m = f.call(t, 'type') ? t.type : t;
      let x = f.call(t, 'namespace') ? t.namespace.split('.') : []; if (s = h = u = i = i || r, i.nodeType !== 3 && i.nodeType !== 8 && !wt.test(m + w.event.triggered) && (m.indexOf('.') > -1 && (m = (x = m.split('.')).shift(), x.sort()), c = m.indexOf(':') < 0 && `on${m}`, t = t[w.expando] ? t : new w.Event(m, typeof t === 'object' && t), t.isTrigger = o ? 2 : 3, t.namespace = x.join('.'), t.rnamespace = t.namespace ? new RegExp(`(^|\\.)${x.join('\\.(?:.*\\.|)')}(\\.|$)`) : null, t.result = void 0, t.target || (t.target = i), n = n == null ? [t] : w.makeArray(n, [t]), d = w.event.special[m] || {}, o || !d.trigger || !1 !== d.trigger.apply(i, n))) {
        if (!o && !d.noBubble && !y(i)) {
          for (l = d.delegateType || m, wt.test(l + m) || (s = s.parentNode); s; s = s.parentNode) v.push(s), u = s;
          u === (i.ownerDocument || r) && v.push(u.defaultView || u.parentWindow || e);
        }
        a = 0; while ((s = v[a++]) && !t.isPropagationStopped()) h = s, t.type = a > 1 ? l : d.bindType || m, (p = (J.get(s, 'events') || {})[t.type] && J.get(s, 'handle')) && p.apply(s, n), (p = c && s[c]) && p.apply && Y(s) && (t.result = p.apply(s, n), !1 === t.result && t.preventDefault()); return t.type = m, o || t.isDefaultPrevented() || d._default && !1 !== d._default.apply(v.pop(), n) || !Y(i) || c && g(i[m]) && !y(i) && ((u = i[c]) && (i[c] = null), w.event.triggered = m, t.isPropagationStopped() && h.addEventListener(m, Tt), i[m](), t.isPropagationStopped() && h.removeEventListener(m, Tt), w.event.triggered = void 0, u && (i[c] = u)), t.result;
      }
    },
    simulate(e, t, n) {
      const r = w.extend(new w.Event(), n, { type: e, isSimulated: !0 });
      w.event.trigger(r, null, t);
    },
  }), w.fn.extend({ trigger(e, t) { return this.each(function () { w.event.trigger(e, t, this); }); }, triggerHandler(e, t) { const n = this[0]; if (n) return w.event.trigger(e, t, n, !0); } }), h.focusin || w.each({ focus: 'focusin', blur: 'focusout' }, (e, t) => {
    const n = function (e) { w.event.simulate(t, e.target, w.event.fix(e)); };
    w.event.special[t] = {
      setup() {
        const r = this.ownerDocument || this;
        const i = J.access(r, t);
        i || r.addEventListener(e, n, !0), J.access(r, t, (i || 0) + 1);
      },
      teardown() {
        const r = this.ownerDocument || this;
        const i = J.access(r, t) - 1;
        i ? J.access(r, t, i) : (r.removeEventListener(e, n, !0), J.remove(r, t));
      },
    };
  }); const Ct = e.location;
  let Et = Date.now();
  const kt = /\?/;
  w.parseXML = function (t) { let n; if (!t || typeof t !== 'string') return null; try { n = (new e.DOMParser()).parseFromString(t, 'text/xml'); } catch (e) { n = void 0; } return n && !n.getElementsByTagName('parsererror').length || w.error(`Invalid XML: ${t}`), n; }; const St = /\[\]$/;
  const Dt = /\r?\n/g;
  const Nt = /^(?:submit|button|image|reset|file)$/i;
  const At = /^(?:input|select|textarea|keygen)/i;

  function jt(e, t, n, r) {
    let i; if (Array.isArray(t)) w.each(t, (t, i) => { n || St.test(e) ? r(e, i) : jt(`${e}[${typeof i === 'object' && i != null ? t : ''}]`, i, n, r); });
    else if (n || x(t) !== 'object') r(e, t);
    else for (i in t) jt(`${e}[${i}]`, t[i], n, r);
  }
  w.param = function (e, t) {
    let n; const r = [];
    const i = function (e, t) {
      const n = g(t) ? t() : t;
      r[r.length] = `${encodeURIComponent(e)}=${encodeURIComponent(n == null ? '' : n)}`;
    }; if (Array.isArray(e) || e.jquery && !w.isPlainObject(e)) w.each(e, function () { i(this.name, this.value); });
    else for (n in e) jt(n, e[n], t, i); return r.join('&');
  }, w.fn.extend({ serialize() { return w.param(this.serializeArray()); }, serializeArray() { return this.map(function () { const e = w.prop(this, 'elements'); return e ? w.makeArray(e) : this; }).filter(function () { const e = this.type; return this.name && !w(this).is(':disabled') && At.test(this.nodeName) && !Nt.test(e) && (this.checked || !pe.test(e)); }).map(function (e, t) { const n = w(this).val(); return n == null ? null : Array.isArray(n) ? w.map(n, (e) => ({ name: t.name, value: e.replace(Dt, '\r\n') })) : { name: t.name, value: n.replace(Dt, '\r\n') }; }).get(); } }); const qt = /%20/g;
  const Lt = /#.*$/;
  const Ht = /([?&])_=[^&]*/;
  const Ot = /^(.*?):[ \t]*([^\r\n]*)$/gm;
  const Pt = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/;
  const Mt = /^(?:GET|HEAD)$/;
  const Rt = /^\/\//;
  const It = {};
  const Wt = {};
  const $t = '*/'.concat('*');
  const Bt = r.createElement('a');
  Bt.href = Ct.href;

  function Ft(e) {
    return function (t, n) {
      typeof t !== 'string' && (n = t, t = '*'); let r; let i = 0;
      const o = t.toLowerCase().match(M) || []; if (g(n)) while (r = o[i++]) r[0] === '+' ? (r = r.slice(1) || '*', (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n);
    };
  }

  function _t(e, t, n, r) {
    const i = {};
    const o = e === Wt;

    function a(s) { let u; return i[s] = !0, w.each(e[s] || [], (e, s) => { const l = s(t, n, r); return typeof l !== 'string' || o || i[l] ? o ? !(u = l) : void 0 : (t.dataTypes.unshift(l), a(l), !1); }), u; } return a(t.dataTypes[0]) || !i['*'] && a('*');
  }

  function zt(e, t) {
    let n; let r; const
      i = w.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && w.extend(!0, e, r), e;
  }

  function Xt(e, t, n) {
    let r; let i; let o; let a; const s = e.contents;
    const u = e.dataTypes; while (u[0] === '*') u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader('Content-Type')); if (r) for (i in s) if (s[i] && s[i].test(r)) { u.unshift(i); break; }
    if (u[0] in n) o = u[0];
    else {
      for (i in n) {
        if (!u[0] || e.converters[`${i} ${u[0]}`]) { o = i; break; }
        a || (a = i);
      }
      o = o || a;
    } if (o) return o !== u[0] && u.unshift(o), n[o];
  }

  function Ut(e, t, n, r) {
    let i; let o; let a; let s; let u; const l = {};
    const c = e.dataTypes.slice(); if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a];
    o = c.shift(); while (o) {
      if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) {
        if (o === '*') o = u;
        else if (u !== '*' && u !== o) {
          if (!(a = l[`${u} ${o}`] || l[`* ${o}`])) for (i in l) if ((s = i.split(' '))[1] === o && (a = l[`${u} ${s[0]}`] || l[`* ${s[0]}`])) { !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1])); break; }
          if (!0 !== a) {
            if (a && e.throws) t = a(t);
            else try { t = a(t); } catch (e) { return { state: 'parsererror', error: a ? e : `No conversion from ${u} to ${o}` }; }
          }
        }
      }
    } return { state: 'success', data: t };
  }
  w.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: Ct.href,
      type: 'GET',
      isLocal: Pt.test(Ct.protocol),
      global: !0,
      processData: !0,
      async: !0,
      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
      accepts: {
        '*': $t, text: 'text/plain', html: 'text/html', xml: 'application/xml, text/xml', json: 'application/json, text/javascript',
      },
      contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ },
      responseFields: { xml: 'responseXML', text: 'responseText', json: 'responseJSON' },
      converters: {
        '* text': String, 'text html': !0, 'text json': JSON.parse, 'text xml': w.parseXML,
      },
      flatOptions: { url: !0, context: !0 },
    },
    ajaxSetup(e, t) { return t ? zt(zt(e, w.ajaxSettings), t) : zt(w.ajaxSettings, e); },
    ajaxPrefilter: Ft(It),
    ajaxTransport: Ft(Wt),
    ajax(t, n) {
      typeof t === 'object' && (n = t, t = void 0), n = n || {}; let i; let o; let a; let s; let u; let l; let c; let f; let p; let d; const h = w.ajaxSetup({}, n);
      const g = h.context || h;
      const y = h.context && (g.nodeType || g.jquery) ? w(g) : w.event;
      const v = w.Deferred();
      const m = w.Callbacks('once memory');
      let x = h.statusCode || {};
      const b = {};
      const T = {};
      let C = 'canceled';
      var E = {
        readyState: 0,
        getResponseHeader(e) {
          let t; if (c) {
            if (!s) { s = {}; while (t = Ot.exec(a)) s[t[1].toLowerCase()] = t[2]; }
            t = s[e.toLowerCase()];
          } return t == null ? null : t;
        },
        getAllResponseHeaders() { return c ? a : null; },
        setRequestHeader(e, t) { return c == null && (e = T[e.toLowerCase()] = T[e.toLowerCase()] || e, b[e] = t), this; },
        overrideMimeType(e) { return c == null && (h.mimeType = e), this; },
        statusCode(e) {
          let t; if (e) {
            if (c) E.always(e[E.status]);
            else for (t in e) x[t] = [x[t], e[t]];
          }
          return this;
        },
        abort(e) { const t = e || C; return i && i.abort(t), k(0, t), this; },
      }; if (v.promise(E), h.url = (`${t || h.url || Ct.href}`).replace(Rt, `${Ct.protocol}//`), h.type = n.method || n.type || h.method || h.type, h.dataTypes = (h.dataType || '*').toLowerCase().match(M) || [''], h.crossDomain == null) { l = r.createElement('a'); try { l.href = h.url, l.href = l.href, h.crossDomain = `${Bt.protocol}//${Bt.host}` != `${l.protocol}//${l.host}`; } catch (e) { h.crossDomain = !0; } } if (h.data && h.processData && typeof h.data !== 'string' && (h.data = w.param(h.data, h.traditional)), _t(It, h, n, E), c) return E;
      (f = w.event && h.global) && w.active++ == 0 && w.event.trigger('ajaxStart'), h.type = h.type.toUpperCase(), h.hasContent = !Mt.test(h.type), o = h.url.replace(Lt, ''), h.hasContent ? h.data && h.processData && (h.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && (h.data = h.data.replace(qt, '+')) : (d = h.url.slice(o.length), h.data && (h.processData || typeof h.data === 'string') && (o += (kt.test(o) ? '&' : '?') + h.data, delete h.data), !1 === h.cache && (o = o.replace(Ht, '$1'), d = `${kt.test(o) ? '&' : '?'}_=${Et++}${d}`), h.url = o + d), h.ifModified && (w.lastModified[o] && E.setRequestHeader('If-Modified-Since', w.lastModified[o]), w.etag[o] && E.setRequestHeader('If-None-Match', w.etag[o])), (h.data && h.hasContent && !1 !== h.contentType || n.contentType) && E.setRequestHeader('Content-Type', h.contentType), E.setRequestHeader('Accept', h.dataTypes[0] && h.accepts[h.dataTypes[0]] ? h.accepts[h.dataTypes[0]] + (h.dataTypes[0] !== '*' ? `, ${$t}; q=0.01` : '') : h.accepts['*']); for (p in h.headers) E.setRequestHeader(p, h.headers[p]); if (h.beforeSend && (!1 === h.beforeSend.call(g, E, h) || c)) return E.abort(); if (C = 'abort', m.add(h.complete), E.done(h.success), E.fail(h.error), i = _t(Wt, h, n, E)) {
        if (E.readyState = 1, f && y.trigger('ajaxSend', [E, h]), c) return E;
        h.async && h.timeout > 0 && (u = e.setTimeout(() => { E.abort('timeout'); }, h.timeout)); try { c = !1, i.send(b, k); } catch (e) {
          if (c) throw e;
          k(-1, e);
        }
      } else k(-1, 'No Transport');

      function k(t, n, r, s) {
        let l; let p; let d; let b; let T; let
          C = n;
        c || (c = !0, u && e.clearTimeout(u), i = void 0, a = s || '', E.readyState = t > 0 ? 4 : 0, l = t >= 200 && t < 300 || t === 304, r && (b = Xt(h, E, r)), b = Ut(h, b, E, l), l ? (h.ifModified && ((T = E.getResponseHeader('Last-Modified')) && (w.lastModified[o] = T), (T = E.getResponseHeader('etag')) && (w.etag[o] = T)), t === 204 || h.type === 'HEAD' ? C = 'nocontent' : t === 304 ? C = 'notmodified' : (C = b.state, p = b.data, l = !(d = b.error))) : (d = C, !t && C || (C = 'error', t < 0 && (t = 0))), E.status = t, E.statusText = `${n || C}`, l ? v.resolveWith(g, [p, C, E]) : v.rejectWith(g, [E, C, d]), E.statusCode(x), x = void 0, f && y.trigger(l ? 'ajaxSuccess' : 'ajaxError', [E, h, l ? p : d]), m.fireWith(g, [E, C]), f && (y.trigger('ajaxComplete', [E, h]), --w.active || w.event.trigger('ajaxStop')));
      } return E;
    },
    getJSON(e, t, n) { return w.get(e, t, n, 'json'); },
    getScript(e, t) { return w.get(e, void 0, t, 'script'); },
  }), w.each(['get', 'post'], (e, t) => {
    w[t] = function (e, n, r, i) {
      return g(n) && (i = i || r, r = n, n = void 0), w.ajax(w.extend({
        url: e, type: t, dataType: i, data: n, success: r,
      }, w.isPlainObject(e) && e));
    };
  }), w._evalUrl = function (e) {
    return w.ajax({
      url: e, type: 'GET', dataType: 'script', cache: !0, async: !1, global: !1, throws: !0,
    });
  }, w.fn.extend({
    wrapAll(e) { let t; return this[0] && (g(e) && (e = e.call(this[0])), t = w(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () { let e = this; while (e.firstElementChild) e = e.firstElementChild; return e; }).append(this)), this; },
    wrapInner(e) {
      return g(e) ? this.each(function (t) { w(this).wrapInner(e.call(this, t)); }) : this.each(function () {
        const t = w(this);
        const n = t.contents();
        n.length ? n.wrapAll(e) : t.append(e);
      });
    },
    wrap(e) { const t = g(e); return this.each(function (n) { w(this).wrapAll(t ? e.call(this, n) : e); }); },
    unwrap(e) { return this.parent(e).not('body').each(function () { w(this).replaceWith(this.childNodes); }), this; },
  }), w.expr.pseudos.hidden = function (e) { return !w.expr.pseudos.visible(e); }, w.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length); }, w.ajaxSettings.xhr = function () { try { return new e.XMLHttpRequest(); } catch (e) {} }; const Vt = { 0: 200, 1223: 204 };
  let Gt = w.ajaxSettings.xhr();
  h.cors = !!Gt && 'withCredentials' in Gt, h.ajax = Gt = !!Gt, w.ajaxTransport((t) => {
    let n; let
      r; if (h.cors || Gt && !t.crossDomain) {
      return {
        send(i, o) {
          let a; const
            s = t.xhr(); if (s.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields) for (a in t.xhrFields) s[a] = t.xhrFields[a];
          t.mimeType && s.overrideMimeType && s.overrideMimeType(t.mimeType), t.crossDomain || i['X-Requested-With'] || (i['X-Requested-With'] = 'XMLHttpRequest'); for (a in i) s.setRequestHeader(a, i[a]);
          n = function (e) { return function () { n && (n = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, e === 'abort' ? s.abort() : e === 'error' ? typeof s.status !== 'number' ? o(0, 'error') : o(s.status, s.statusText) : o(Vt[s.status] || s.status, s.statusText, (s.responseType || 'text') !== 'text' || typeof s.responseText !== 'string' ? { binary: s.response } : { text: s.responseText }, s.getAllResponseHeaders())); }; }, s.onload = n(), r = s.onerror = s.ontimeout = n('error'), void 0 !== s.onabort ? s.onabort = r : s.onreadystatechange = function () { s.readyState === 4 && e.setTimeout(() => { n && r(); }); }, n = n('abort'); try { s.send(t.hasContent && t.data || null); } catch (e) { if (n) throw e; }
        },
        abort() { n && n(); },
      };
    }
  }), w.ajaxPrefilter((e) => { e.crossDomain && (e.contents.script = !1); }), w.ajaxSetup({ accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { 'text script': function (e) { return w.globalEval(e), e; } } }), w.ajaxPrefilter('script', (e) => { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = 'GET'); }), w.ajaxTransport('script', (e) => {
    if (e.crossDomain) {
      let t; let
        n; return { send(i, o) { t = w('<script>').prop({ charset: e.scriptCharset, src: e.url }).on('load error', n = function (e) { t.remove(), n = null, e && o(e.type === 'error' ? 404 : 200, e.type); }), r.head.appendChild(t[0]); }, abort() { n && n(); } };
    }
  }); const Yt = [];
  const Qt = /(=)\?(?=&|$)|\?\?/;
  w.ajaxSetup({ jsonp: 'callback', jsonpCallback() { const e = Yt.pop() || `${w.expando}_${Et++}`; return this[e] = !0, e; } }), w.ajaxPrefilter('json jsonp', (t, n, r) => {
    let i; let o; let a; const
      s = !1 !== t.jsonp && (Qt.test(t.url) ? 'url' : typeof t.data === 'string' && (t.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && Qt.test(t.data) && 'data'); if (s || t.dataTypes[0] === 'jsonp') return i = t.jsonpCallback = g(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(Qt, `$1${i}`) : !1 !== t.jsonp && (t.url += `${(kt.test(t.url) ? '&' : '?') + t.jsonp}=${i}`), t.converters['script json'] = function () { return a || w.error(`${i} was not called`), a[0]; }, t.dataTypes[0] = 'json', o = e[i], e[i] = function () { a = arguments; }, r.always(() => { void 0 === o ? w(e).removeProp(i) : e[i] = o, t[i] && (t.jsonpCallback = n.jsonpCallback, Yt.push(i)), a && g(o) && o(a[0]), a = o = void 0; }), 'script';
  }), h.createHTMLDocument = (function () { const e = r.implementation.createHTMLDocument('').body; return e.innerHTML = '<form></form><form></form>', e.childNodes.length === 2; }()), w.parseHTML = function (e, t, n) {
    if (typeof e !== 'string') return []; typeof t === 'boolean' && (n = t, t = !1); let i; let o; let
      a; return t || (h.createHTMLDocument ? ((i = (t = r.implementation.createHTMLDocument('')).createElement('base')).href = r.location.href, t.head.appendChild(i)) : t = r), o = A.exec(e), a = !n && [], o ? [t.createElement(o[1])] : (o = xe([e], t, a), a && a.length && w(a).remove(), w.merge([], o.childNodes));
  }, w.fn.load = function (e, t, n) {
    let r; let i; let o; const a = this;
    const s = e.indexOf(' '); return s > -1 && (r = vt(e.slice(s)), e = e.slice(0, s)), g(t) ? (n = t, t = void 0) : t && typeof t === 'object' && (i = 'POST'), a.length > 0 && w.ajax({
      url: e, type: i || 'GET', dataType: 'html', data: t,
    }).done(function (e) { o = arguments, a.html(r ? w('<div>').append(w.parseHTML(e)).find(r) : e); }).always(n && ((e, t) => { a.each(function () { n.apply(this, o || [e.responseText, t, e]); }); })), this;
  }, w.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], (e, t) => { w.fn[t] = function (e) { return this.on(t, e); }; }), w.expr.pseudos.animated = function (e) { return w.grep(w.timers, (t) => e === t.elem).length; }, w.offset = {
    setOffset(e, t, n) {
      let r; let i; let o; let a; let s; let u; let l; const c = w.css(e, 'position');
      const f = w(e);
      const p = {}; c === 'static' && (e.style.position = 'relative'), s = f.offset(), o = w.css(e, 'top'), u = w.css(e, 'left'), (l = (c === 'absolute' || c === 'fixed') && (o + u).indexOf('auto') > -1) ? (a = (r = f.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), g(t) && (t = t.call(e, n, w.extend({}, s))), t.top != null && (p.top = t.top - s.top + a), t.left != null && (p.left = t.left - s.left + i), 'using' in t ? t.using.call(e, p) : f.css(p);
    },
  }, w.fn.extend({
    offset(e) {
      if (arguments.length) return void 0 === e ? this : this.each(function (t) { w.offset.setOffset(this, e, t); }); let t; let n; const
        r = this[0]; if (r) return r.getClientRects().length ? (t = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: t.top + n.pageYOffset, left: t.left + n.pageXOffset }) : { top: 0, left: 0 };
    },
    position() {
      if (this[0]) {
        let e; let t; let n; const r = this[0];
        let i = { top: 0, left: 0 }; if (w.css(r, 'position') === 'fixed') t = r.getBoundingClientRect();
        else {
          t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && w.css(e, 'position') === 'static') e = e.parentNode;
          e && e !== r && e.nodeType === 1 && ((i = w(e).offset()).top += w.css(e, 'borderTopWidth', !0), i.left += w.css(e, 'borderLeftWidth', !0));
        } return { top: t.top - i.top - w.css(r, 'marginTop', !0), left: t.left - i.left - w.css(r, 'marginLeft', !0) };
      }
    },
    offsetParent() { return this.map(function () { let e = this.offsetParent; while (e && w.css(e, 'position') === 'static') e = e.offsetParent; return e || be; }); },
  }), w.each({ scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' }, (e, t) => {
    const n = t === 'pageYOffset';
    w.fn[e] = function (r) {
      return z(this, (e, r, i) => {
        let o; if (y(e) ? o = e : e.nodeType === 9 && (o = e.defaultView), void 0 === i) return o ? o[t] : e[r];
        o ? o.scrollTo(n ? o.pageXOffset : i, n ? i : o.pageYOffset) : e[r] = i;
      }, e, r, arguments.length);
    };
  }), w.each(['top', 'left'], (e, t) => { w.cssHooks[t] = _e(h.pixelPosition, (e, n) => { if (n) return n = Fe(e, t), We.test(n) ? `${w(e).position()[t]}px` : n; }); }), w.each({ Height: 'height', Width: 'width' }, (e, t) => {
    w.each({ padding: `inner${e}`, content: t, '': `outer${e}` }, (n, r) => {
      w.fn[r] = function (i, o) {
        const a = arguments.length && (n || typeof i !== 'boolean');
        const s = n || (!0 === i || !0 === o ? 'margin' : 'border'); return z(this, (t, n, i) => { let o; return y(t) ? r.indexOf('outer') === 0 ? t[`inner${e}`] : t.document.documentElement[`client${e}`] : t.nodeType === 9 ? (o = t.documentElement, Math.max(t.body[`scroll${e}`], o[`scroll${e}`], t.body[`offset${e}`], o[`offset${e}`], o[`client${e}`])) : void 0 === i ? w.css(t, n, s) : w.style(t, n, i, s); }, t, a ? i : void 0, a);
      };
    });
  }), w.each('blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu'.split(' '), (e, t) => { w.fn[t] = function (e, n) { return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t); }; }), w.fn.extend({ hover(e, t) { return this.mouseenter(e).mouseleave(t || e); } }), w.fn.extend({
    bind(e, t, n) { return this.on(e, null, t, n); }, unbind(e, t) { return this.off(e, null, t); }, delegate(e, t, n, r) { return this.on(t, e, n, r); }, undelegate(e, t, n) { return arguments.length === 1 ? this.off(e, '**') : this.off(t, e || '**', n); },
  }), w.proxy = function (e, t) {
    let n; let r; let
      i; if (typeof t === 'string' && (n = e[t], t = e, e = n), g(e)) return r = o.call(arguments, 2), i = function () { return e.apply(t || this, r.concat(o.call(arguments))); }, i.guid = e.guid = e.guid || w.guid++, i;
  }, w.holdReady = function (e) { e ? w.readyWait++ : w.ready(!0); }, w.isArray = Array.isArray, w.parseJSON = JSON.parse, w.nodeName = N, w.isFunction = g, w.isWindow = y, w.camelCase = G, w.type = x, w.now = Date.now, w.isNumeric = function (e) { const t = w.type(e); return (t === 'number' || t === 'string') && !isNaN(e - parseFloat(e)); }, typeof define === 'function' && define.amd && define('jquery', [], () => w); const Jt = e.jQuery;
  const Kt = e.$; return w.noConflict = function (t) { return e.$ === w && (e.$ = Kt), t && e.jQuery === w && (e.jQuery = Jt), w; }, t || (e.jQuery = e.$ = w), w;
}));

/* http://keith-wood.name/countdown.html
   Countdown for jQuery v1.5.6.
   Written by Keith Wood (kbwood{at}iinet.com.au) January 2008.
   Dual licensed under the GPL (http://dev.jquery.com/browser/trunk/jquery/GPL-LICENSE.txt) and
   MIT (http://dev.jquery.com/browser/trunk/jquery/MIT-LICENSE.txt) licenses.
   Please attribute the author if you use it. */

/* Display a countdown timer.
   Attach it with options like:
   $('div selector').countdown(
       {until: new Date(2009, 1 - 1, 1, 0, 0, 0), onExpiry: happyNewYear}); */

(function ($) { // Hide scope, no $ conflict
  /* Countdown manager. */
  function Countdown() {
    this.regional = []; // Available regional settings, indexed by language code
    this.regional[''] = { // Default regional settings
      // The display texts for the counters
      labels: ['Years', 'Months', 'Weeks', 'Days', 'Hours', 'Mins', 'Secs'],
      // The display texts for the counters if only one
      labels1: ['Year', 'Month', 'Week', 'Day', 'Hour', 'Min', 'Sec'],
      compactLabels: ['y', 'm', 'w', 'd'], // The compact texts for the counters
      timeSeparator: ':', // Separator for time periods
      isRTL: false, // True for right-to-left languages, false for left-to-right
    };
    this._defaults = {
      until: null, // new Date(year, mth - 1, day, hr, min, sec) - date/time to count down to
      // or numeric for seconds offset, or string for unit offset(s):
      // 'Y' years, 'O' months, 'W' weeks, 'D' days, 'H' hours, 'M' minutes, 'S' seconds
      since: null, // new Date(year, mth - 1, day, hr, min, sec) - date/time to count up from
      // or numeric for seconds offset, or string for unit offset(s):
      // 'Y' years, 'O' months, 'W' weeks, 'D' days, 'H' hours, 'M' minutes, 'S' seconds
      timezone: null, // The timezone (hours or minutes from GMT) for the target times,
      // or null for client local
      serverSync: null, // A function to retrieve the current server time for synchronisation
      format: 'dHMS', // Format for display - upper case for always, lower case only if non-zero,
      // 'Y' years, 'O' months, 'W' weeks, 'D' days, 'H' hours, 'M' minutes, 'S' seconds
      layout: '', // Build your own layout for the countdown
      compact: false, // True to display in a compact format, false for an expanded one
      description: '', // The description displayed for the countdown
      expiryUrl: '', // A URL to load upon expiry, replacing the current page
      expiryText: '', // Text to display upon expiry, replacing the countdown
      alwaysExpire: false, // True to trigger onExpiry even if never counted down
      onExpiry: null, // Callback when the countdown expires -
      // receives no parameters and 'this' is the containing division
      onTick: null, // Callback when the countdown is updated -
      // receives int[7] being the breakdown by period (based on format)
      // and 'this' is the containing division
    };
    $.extend(this._defaults, this.regional['']);
  }

  const PROP_NAME = 'countdown';

  const Y = 0; // Years
  const O = 1; // Months
  const W = 2; // Weeks
  const D = 3; // Days
  const H = 4; // Hours
  const M = 5; // Minutes
  const S = 6; // Seconds

  $.extend(Countdown.prototype, {
    /* Class name added to elements to indicate already configured with countdown. */
    markerClassName: 'hasCountdown',

    /* Shared timer for all countdowns. */
    _timer: setInterval(() => { $.countdown._updateTargets(); }, 980),
    /* List of currently active countdown targets. */
    _timerTargets: [],

    /* Override the default settings for all instances of the countdown widget.
       @param  options  (object) the new settings to use as defaults */
    setDefaults(options) {
      this._resetExtraLabels(this._defaults, options);
      extendRemove(this._defaults, options || {});
    },

    /* Convert a date/time to UTC.
       @param  tz     (number) the hour or minute offset from GMT, e.g. +9, -360
       @param  year   (Date) the date/time in that timezone or
                      (number) the year in that timezone
       @param  month  (number, optional) the month (0 - 11) (omit if year is a Date)
       @param  day    (number, optional) the day (omit if year is a Date)
       @param  hours  (number, optional) the hour (omit if year is a Date)
       @param  mins   (number, optional) the minute (omit if year is a Date)
       @param  secs   (number, optional) the second (omit if year is a Date)
       @param  ms     (number, optional) the millisecond (omit if year is a Date)
       @return  (Date) the equivalent UTC date/time */
    UTCDate(tz, year, month, day, hours, mins, secs, ms) {
      if (typeof year === 'object' && year.constructor == Date) {
        ms = year.getMilliseconds();
        secs = year.getSeconds();
        mins = year.getMinutes();
        hours = year.getHours();
        day = year.getDate();
        month = year.getMonth();
        year = year.getFullYear();
      }
      const d = new Date();
      d.setUTCFullYear(year);
      d.setUTCDate(1);
      d.setUTCMonth(month || 0);
      d.setUTCDate(day || 1);
      d.setUTCHours(hours || 0);
      d.setUTCMinutes((mins || 0) - (Math.abs(tz) < 30 ? tz * 60 : tz));
      d.setUTCSeconds(secs || 0);
      d.setUTCMilliseconds(ms || 0);
      return d;
    },

    /* Convert a set of periods into seconds.
       Averaged for months and years.
       @param  periods  (number[7]) the periods per year/month/week/day/hour/minute/second
       @return  (number) the corresponding number of seconds */
    periodsToSeconds(periods) {
      return periods[0] * 31557600 + periods[1] * 2629800 + periods[2] * 604800
        + periods[3] * 86400 + periods[4] * 3600 + periods[5] * 60 + periods[6];
    },

    /* Retrieve one or more settings values.
       @param  name  (string, optional) the name of the setting to retrieve
                     or 'all' for all instance settings or omit for all default settings
       @return  (any) the requested setting(s) */
    _settingsCountdown(target, name) {
      if (!name) {
        return $.countdown._defaults;
      }
      const inst = $.data(target, PROP_NAME);
      return (name == 'all' ? inst.options : inst.options[name]);
    },

    /* Attach the countdown widget to a div.
       @param  target   (element) the containing division
       @param  options  (object) the initial settings for the countdown */
    _attachCountdown(target, options) {
      const $target = $(target);
      if ($target.hasClass(this.markerClassName)) {
        return;
      }
      $target.addClass(this.markerClassName);
      const inst = {
        options: $.extend({}, options),
        _periods: [0, 0, 0, 0, 0, 0, 0],
      };
      $.data(target, PROP_NAME, inst);
      this._changeCountdown(target);
    },

    /* Add a target to the list of active ones.
       @param  target  (element) the countdown target */
    _addTarget(target) {
      if (!this._hasTarget(target)) {
        this._timerTargets.push(target);
      }
    },

    /* See if a target is in the list of active ones.
       @param  target  (element) the countdown target
       @return  (boolean) true if present, false if not */
    _hasTarget(target) {
      return ($.inArray(target, this._timerTargets) > -1);
    },

    /* Remove a target from the list of active ones.
       @param  target  (element) the countdown target */
    _removeTarget(target) {
      this._timerTargets = $.map(
        this._timerTargets,
        (value) => (value == target ? null : value),
      ); // delete entry
    },

    /* Update each active timer target. */
    _updateTargets() {
      for (let i = 0; i < this._timerTargets.length; i++) {
        this._updateCountdown(this._timerTargets[i]);
      }
    },

    /* Redisplay the countdown with an updated display.
       @param  target  (jQuery) the containing division
       @param  inst    (object) the current settings for this instance */
    _updateCountdown(target, inst) {
      const $target = $(target);
      inst = inst || $.data(target, PROP_NAME);
      if (!inst) {
        return;
      }
      $target.html(this._generateHTML(inst));
      $target[`${this._get(inst, 'isRTL') ? 'add' : 'remove'}Class`]('countdown_rtl');
      const onTick = this._get(inst, 'onTick');
      if (onTick) {
        const periods = inst._hold != 'lap' ? inst._periods
          : this._calculatePeriods(inst, inst._show, new Date());
        onTick.apply(target, [periods]);
      }
      const expired = inst._hold != 'pause'
        && (inst._since ? inst._now.getTime() < inst._since.getTime()
          : inst._now.getTime() >= inst._until.getTime());
      if (expired && !inst._expiring) {
        inst._expiring = true;
        if (this._hasTarget(target) || this._get(inst, 'alwaysExpire')) {
          this._removeTarget(target);
          const onExpiry = this._get(inst, 'onExpiry');
          if (onExpiry) {
            onExpiry.apply(target, []);
          }
          const expiryText = this._get(inst, 'expiryText');
          if (expiryText) {
            const layout = this._get(inst, 'layout');
            inst.options.layout = expiryText;
            this._updateCountdown(target, inst);
            inst.options.layout = layout;
          }
          const expiryUrl = this._get(inst, 'expiryUrl');
          if (expiryUrl) {
            window.location = expiryUrl;
          }
        }
        inst._expiring = false;
      } else if (inst._hold == 'pause') {
        this._removeTarget(target);
      }
      $.data(target, PROP_NAME, inst);
    },

    /* Reconfigure the settings for a countdown div.
       @param  target   (element) the containing division
       @param  options  (object) the new settings for the countdown or
                        (string) an individual property name
       @param  value    (any) the individual property value
                        (omit if options is an object) */
    _changeCountdown(target, options, value) {
      options = options || {};
      if (typeof options === 'string') {
        const name = options;
        options = {};
        options[name] = value;
      }
      const inst = $.data(target, PROP_NAME);
      if (inst) {
        this._resetExtraLabels(inst.options, options);
        extendRemove(inst.options, options);
        this._adjustSettings(target, inst);
        $.data(target, PROP_NAME, inst);
        const now = new Date();
        if ((inst._since && inst._since < now)
          || (inst._until && inst._until > now)) {
          this._addTarget(target);
        }
        this._updateCountdown(target, inst);
      }
    },

    /* Reset any extra labelsn and compactLabelsn entries if changing labels.
       @param  base     (object) the options to be updated
       @param  options  (object) the new option values */
    _resetExtraLabels(base, options) {
      let changingLabels = false;
      for (var n in options) {
        if (n.match(/[Ll]abels/)) {
          changingLabels = true;
          break;
        }
      }
      if (changingLabels) {
        for (var n in base) { // Remove custom numbered labels
          if (n.match(/[Ll]abels[0-9]/)) {
            base[n] = null;
          }
        }
      }
    },

    /* Calculate interal settings for an instance.
       @param  target  (element) the containing division
       @param  inst    (object) the current settings for this instance */
    _adjustSettings(target, inst) {
      let serverSync = this._get(inst, 'serverSync');
      serverSync = (serverSync ? serverSync.apply(target, []) : null);
      const now = new Date();
      let timezone = this._get(inst, 'timezone');
      timezone = (timezone == null ? -now.getTimezoneOffset() : timezone);
      inst._since = this._get(inst, 'since');
      if (inst._since != null) {
        inst._since = this.UTCDate(timezone, this._determineTime(inst._since, null));
        if (inst._since && serverSync) {
          inst._since.setMilliseconds(inst._since.getMilliseconds()
            + now.getTime() - serverSync.getTime());
        }
      }
      inst._until = this.UTCDate(timezone, this._determineTime(this._get(inst, 'until'), now));
      if (serverSync) {
        inst._until.setMilliseconds(inst._until.getMilliseconds()
          + now.getTime() - serverSync.getTime());
      }
      inst._show = this._determineShow(inst);
    },

    /* Remove the countdown widget from a div.
       @param  target  (element) the containing division */
    _destroyCountdown(target) {
      const $target = $(target);
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
      this._removeTarget(target);
      $target.removeClass(this.markerClassName).empty();
      $.removeData(target, PROP_NAME);
    },

    /* Pause a countdown widget at the current time.
       Stop it running but remember and display the current time.
       @param  target  (element) the containing division */
    _pauseCountdown(target) {
      this._hold(target, 'pause');
    },

    /* Pause a countdown widget at the current time.
       Stop the display but keep the countdown running.
       @param  target  (element) the containing division */
    _lapCountdown(target) {
      this._hold(target, 'lap');
    },

    /* Resume a paused countdown widget.
       @param  target  (element) the containing division */
    _resumeCountdown(target) {
      this._hold(target, null);
    },

    /* Pause or resume a countdown widget.
       @param  target  (element) the containing division
       @param  hold    (string) the new hold setting */
    _hold(target, hold) {
      const inst = $.data(target, PROP_NAME);
      if (inst) {
        if (inst._hold == 'pause' && !hold) {
          inst._periods = inst._savePeriods;
          const sign = (inst._since ? '-' : '+');
          inst[inst._since ? '_since' : '_until'] = this._determineTime(`${sign + inst._periods[0]}y${
            sign}${inst._periods[1]}o${sign}${inst._periods[2]}w${
            sign}${inst._periods[3]}d${sign}${inst._periods[4]}h${
            sign}${inst._periods[5]}m${sign}${inst._periods[6]}s`);
          this._addTarget(target);
        }
        inst._hold = hold;
        inst._savePeriods = (hold == 'pause' ? inst._periods : null);
        $.data(target, PROP_NAME, inst);
        this._updateCountdown(target, inst);
      }
    },

    /* Return the current time periods.
       @param  target  (element) the containing division
       @return  (number[7]) the current periods for the countdown */
    _getTimesCountdown(target) {
      const inst = $.data(target, PROP_NAME);
      return (!inst ? null : (!inst._hold ? inst._periods
        : this._calculatePeriods(inst, inst._show, new Date())));
    },

    /* Get a setting value, defaulting if necessary.
       @param  inst  (object) the current settings for this instance
       @param  name  (string) the name of the required setting
       @return  (any) the setting's value or a default if not overridden */
    _get(inst, name) {
      return (inst.options[name] != null
        ? inst.options[name] : $.countdown._defaults[name]);
    },

    /* A time may be specified as an exact value or a relative one.
       @param  setting      (string or number or Date) - the date/time value
                            as a relative or absolute value
       @param  defaultTime  (Date) the date/time to use if no other is supplied
       @return  (Date) the corresponding date/time */
    _determineTime(setting, defaultTime) {
      const offsetNumeric = function (offset) { // e.g. +300, -2
        const time = new Date();
        time.setTime(time.getTime() + offset * 1000);
        return time;
      };
      const offsetString = function (offset) { // e.g. '+2d', '-4w', '+3h +30m'
        offset = offset.toLowerCase();
        const time = new Date();
        let year = time.getFullYear();
        let month = time.getMonth();
        let day = time.getDate();
        let hour = time.getHours();
        let minute = time.getMinutes();
        let second = time.getSeconds();
        const pattern = /([+-]?[0-9]+)\s*(s|m|h|d|w|o|y)?/g;
        let matches = pattern.exec(offset);
        while (matches) {
          switch (matches[2] || 's') {
            case 's':
              second += parseInt(matches[1], 10);
              break;
            case 'm':
              minute += parseInt(matches[1], 10);
              break;
            case 'h':
              hour += parseInt(matches[1], 10);
              break;
            case 'd':
              day += parseInt(matches[1], 10);
              break;
            case 'w':
              day += parseInt(matches[1], 10) * 7;
              break;
            case 'o':
              month += parseInt(matches[1], 10);
              day = Math.min(day, $.countdown._getDaysInMonth(year, month));
              break;
            case 'y':
              year += parseInt(matches[1], 10);
              day = Math.min(day, $.countdown._getDaysInMonth(year, month));
              break;
          }
          matches = pattern.exec(offset);
        }
        return new Date(year, month, day, hour, minute, second, 0);
      };
      const time = (setting == null ? defaultTime
        : (typeof setting === 'string' ? offsetString(setting)
          : (typeof setting === 'number' ? offsetNumeric(setting) : setting)));
      if (time) time.setMilliseconds(0);
      return time;
    },

    /* Determine the number of days in a month.
       @param  year   (number) the year
       @param  month  (number) the month
       @return  (number) the days in that month */
    _getDaysInMonth(year, month) {
      return 32 - new Date(year, month, 32).getDate();
    },

    /* Generate the HTML to display the countdown widget.
       @param  inst  (object) the current settings for this instance
       @return  (string) the new HTML for the countdown display */
    _generateHTML(inst) {
      // Determine what to show
      inst._periods = periods = (inst._hold ? inst._periods
        : this._calculatePeriods(inst, inst._show, new Date()));
      // Show all 'asNeeded' after first non-zero value
      let shownNonZero = false;
      let showCount = 0;
      const show = $.extend({}, inst._show);
      for (let period = 0; period < inst._show.length; period++) {
        shownNonZero |= (inst._show[period] == '?' && periods[period] > 0);
        show[period] = (inst._show[period] == '?' && !shownNonZero ? null : inst._show[period]);
        showCount += (show[period] ? 1 : 0);
      }
      const compact = this._get(inst, 'compact');
      const layout = this._get(inst, 'layout');
      const labels = (compact ? this._get(inst, 'compactLabels') : this._get(inst, 'labels'));
      const timeSeparator = this._get(inst, 'timeSeparator');
      const description = this._get(inst, 'description') || '';
      const showCompact = function (period) {
        const labelsNum = $.countdown._get(inst, `compactLabels${periods[period]}`);
        return (show[period] ? `${periods[period]
          + (labelsNum ? labelsNum[period] : labels[period])} ` : '');
      };
      const showFull = function (period) {
        const labelsNum = $.countdown._get(inst, `labels${periods[period]}`);
        return (show[period]
          ? `<span class="countdown_section"><span class="countdown_amount">${
            periods[period]}</span><br/>${
            labelsNum ? labelsNum[period] : labels[period]}</span>` : '');
      };
      return (layout ? this._buildLayout(inst, show, layout, compact)
        : (`${compact // Compact version
          ? `<span class="countdown_row countdown_amount${
            inst._hold ? ' countdown_holding' : ''}">${
            showCompact(Y)}${showCompact(O)}${showCompact(W)}${showCompact(D)
          }${show[H] ? this._minDigits(periods[H], 2) : ''
          }${show[M] ? (show[H] ? timeSeparator : '')
              + this._minDigits(periods[M], 2) : ''
          }${show[S] ? (show[H] || show[M] ? timeSeparator : '')
              + this._minDigits(periods[S], 2) : ''}`
        // Full version
          : `<span class="countdown_row countdown_show${showCount
          }${inst._hold ? ' countdown_holding' : ''}">${
            showFull(Y)}${showFull(O)}${showFull(W)}${showFull(D)
          }${showFull(H)}${showFull(M)}${showFull(S)}`}</span>${
          description ? `<span class="countdown_row countdown_descr">${description}</span>` : ''}`));
    },

    /* Construct a custom layout.
       @param  inst     (object) the current settings for this instance
       @param  show     (string[7]) flags indicating which periods are requested
       @param  layout   (string) the customised layout
       @param  compact  (boolean) true if using compact labels
       @return  (string) the custom HTML */
    _buildLayout(inst, show, layout, compact) {
      const labels = this._get(inst, (compact ? 'compactLabels' : 'labels'));
      const labelFor = function (index) {
        return ($.countdown._get(
          inst,
          (compact ? 'compactLabels' : 'labels') + inst._periods[index],
        )
          || labels)[index];
      };
      const digit = function (value, position) {
        return Math.floor(value / position) % 10;
      };
      const subs = {
        desc: this._get(inst, 'description'),
        sep: this._get(inst, 'timeSeparator'),
        yl: labelFor(Y),
        yn: inst._periods[Y],
        ynn: this._minDigits(inst._periods[Y], 2),
        ynnn: this._minDigits(inst._periods[Y], 3),
        y1: digit(inst._periods[Y], 1),
        y10: digit(inst._periods[Y], 10),
        y100: digit(inst._periods[Y], 100),
        y1000: digit(inst._periods[Y], 1000),
        ol: labelFor(O),
        on: inst._periods[O],
        onn: this._minDigits(inst._periods[O], 2),
        onnn: this._minDigits(inst._periods[O], 3),
        o1: digit(inst._periods[O], 1),
        o10: digit(inst._periods[O], 10),
        o100: digit(inst._periods[O], 100),
        o1000: digit(inst._periods[O], 1000),
        wl: labelFor(W),
        wn: inst._periods[W],
        wnn: this._minDigits(inst._periods[W], 2),
        wnnn: this._minDigits(inst._periods[W], 3),
        w1: digit(inst._periods[W], 1),
        w10: digit(inst._periods[W], 10),
        w100: digit(inst._periods[W], 100),
        w1000: digit(inst._periods[W], 1000),
        dl: labelFor(D),
        dn: inst._periods[D],
        dnn: this._minDigits(inst._periods[D], 2),
        dnnn: this._minDigits(inst._periods[D], 3),
        d1: digit(inst._periods[D], 1),
        d10: digit(inst._periods[D], 10),
        d100: digit(inst._periods[D], 100),
        d1000: digit(inst._periods[D], 1000),
        hl: labelFor(H),
        hn: inst._periods[H],
        hnn: this._minDigits(inst._periods[H], 2),
        hnnn: this._minDigits(inst._periods[H], 3),
        h1: digit(inst._periods[H], 1),
        h10: digit(inst._periods[H], 10),
        h100: digit(inst._periods[H], 100),
        h1000: digit(inst._periods[H], 1000),
        ml: labelFor(M),
        mn: inst._periods[M],
        mnn: this._minDigits(inst._periods[M], 2),
        mnnn: this._minDigits(inst._periods[M], 3),
        m1: digit(inst._periods[M], 1),
        m10: digit(inst._periods[M], 10),
        m100: digit(inst._periods[M], 100),
        m1000: digit(inst._periods[M], 1000),
        sl: labelFor(S),
        sn: inst._periods[S],
        snn: this._minDigits(inst._periods[S], 2),
        snnn: this._minDigits(inst._periods[S], 3),
        s1: digit(inst._periods[S], 1),
        s10: digit(inst._periods[S], 10),
        s100: digit(inst._periods[S], 100),
        s1000: digit(inst._periods[S], 1000),
      };
      let html = layout;
      // Replace period containers: {p<}...{p>}
      for (let i = 0; i < 7; i++) {
        const period = 'yowdhms'.charAt(i);
        const re = new RegExp(`\\{${period}<\\}(.*)\\{${period}>\\}`, 'g');
        html = html.replace(re, (show[i] ? '$1' : ''));
      }
      // Replace period values: {pn}
      $.each(subs, (n, v) => {
        const re = new RegExp(`\\{${n}\\}`, 'g');
        html = html.replace(re, v);
      });
      return html;
    },

    /* Ensure a numeric value has at least n digits for display.
       @param  value  (number) the value to display
       @param  len    (number) the minimum length
       @return  (string) the display text */
    _minDigits(value, len) {
      value = `${value}`;
      if (value.length >= len) {
        return value;
      }
      value = `0000000000${value}`;
      return value.substr(value.length - len);
    },

    /* Translate the format into flags for each period.
       @param  inst  (object) the current settings for this instance
       @return  (string[7]) flags indicating which periods are requested (?) or
                required (!) by year, month, week, day, hour, minute, second */
    _determineShow(inst) {
      const format = this._get(inst, 'format');
      const show = [];
      show[Y] = (format.match('y') ? '?' : (format.match('Y') ? '!' : null));
      show[O] = (format.match('o') ? '?' : (format.match('O') ? '!' : null));
      show[W] = (format.match('w') ? '?' : (format.match('W') ? '!' : null));
      show[D] = (format.match('d') ? '?' : (format.match('D') ? '!' : null));
      show[H] = (format.match('h') ? '?' : (format.match('H') ? '!' : null));
      show[M] = (format.match('m') ? '?' : (format.match('M') ? '!' : null));
      show[S] = (format.match('s') ? '?' : (format.match('S') ? '!' : null));
      return show;
    },

    /* Calculate the requested periods between now and the target time.
       @param  inst  (object) the current settings for this instance
       @param  show  (string[7]) flags indicating which periods are requested/required
       @param  now   (Date) the current date and time
       @return  (number[7]) the current time periods (always positive)
                by year, month, week, day, hour, minute, second */
    _calculatePeriods(inst, show, now) {
      // Find endpoints
      inst._now = now;
      inst._now.setMilliseconds(0);
      let until = new Date(inst._now.getTime());
      if (inst._since) {
        if (now.getTime() < inst._since.getTime()) {
          inst._now = now = until;
        } else {
          now = inst._since;
        }
      } else {
        until.setTime(inst._until.getTime());
        if (now.getTime() > inst._until.getTime()) {
          inst._now = now = until;
        }
      }
      // Calculate differences by period
      const periods = [0, 0, 0, 0, 0, 0, 0];
      if (show[Y] || show[O]) {
        // Treat end of months as the same
        const lastNow = $.countdown._getDaysInMonth(now.getFullYear(), now.getMonth());
        const lastUntil = $.countdown._getDaysInMonth(until.getFullYear(), until.getMonth());
        const sameDay = (until.getDate() == now.getDate()
          || (until.getDate() >= Math.min(lastNow, lastUntil)
            && now.getDate() >= Math.min(lastNow, lastUntil)));
        const getSecs = function (date) {
          return (date.getHours() * 60 + date.getMinutes()) * 60 + date.getSeconds();
        };
        const months = Math.max(
          0,
          (until.getFullYear() - now.getFullYear()) * 12 + until.getMonth() - now.getMonth()
          + ((until.getDate() < now.getDate() && !sameDay)
            || (sameDay && getSecs(until) < getSecs(now)) ? -1 : 0),
        );
        periods[Y] = (show[Y] ? Math.floor(months / 12) : 0);
        periods[O] = (show[O] ? months - periods[Y] * 12 : 0);
        // Adjust for months difference and end of month if necessary
        const adjustDate = function (date, offset, last) {
          const wasLastDay = (date.getDate() == last);
          const lastDay = $.countdown._getDaysInMonth(
            date.getFullYear() + offset * periods[Y],
            date.getMonth() + offset * periods[O],
          );
          if (date.getDate() > lastDay) {
            date.setDate(lastDay);
          }
          date.setFullYear(date.getFullYear() + offset * periods[Y]);
          date.setMonth(date.getMonth() + offset * periods[O]);
          if (wasLastDay) {
            date.setDate(lastDay);
          }
          return date;
        };
        if (inst._since) {
          until = adjustDate(until, -1, lastUntil);
        } else {
          now = adjustDate(new Date(now.getTime()), +1, lastNow);
        }
      }
      let diff = Math.floor((until.getTime() - now.getTime()) / 1000);
      const extractPeriod = function (period, numSecs) {
        periods[period] = (show[period] ? Math.floor(diff / numSecs) : 0);
        diff -= periods[period] * numSecs;
      };
      extractPeriod(W, 604800);
      extractPeriod(D, 86400);
      extractPeriod(H, 3600);
      extractPeriod(M, 60);
      extractPeriod(S, 1);
      if (diff > 0 && !inst._since) { // Round up if left overs
        const multiplier = [1, 12, 4.3482, 7, 24, 60, 60];
        let lastShown = S;
        let max = 1;
        for (let period = S; period >= Y; period--) {
          if (show[period]) {
            if (periods[lastShown] >= max) {
              periods[lastShown] = 0;
              diff = 1;
            }
            if (diff > 0) {
              periods[period]++;
              diff = 0;
              lastShown = period;
              max = 1;
            }
          }
          max *= multiplier[period];
        }
      }
      return periods;
    },
  });

  /* jQuery extend now ignores nulls!
     @param  target  (object) the object to update
     @param  props   (object) the new settings
     @return  (object) the updated object */
  function extendRemove(target, props) {
    $.extend(target, props);
    for (const name in props) {
      if (props[name] == null) {
        target[name] = null;
      }
    }
    return target;
  }

  /* Process the countdown functionality for a jQuery selection.
     @param  command  (string) the command to run (optional, default 'attach')
     @param  options  (object) the new settings to use for these countdown instances
     @return  (jQuery) for chaining further calls */
  $.fn.countdown = function (options) {
    const otherArgs = Array.prototype.slice.call(arguments, 1);
    if (options == 'getTimes' || options == 'settings') {
      return $.countdown[`_${options}Countdown`]
        .apply($.countdown, [this[0]].concat(otherArgs));
    }
    return this.each(function () {
      if (typeof options === 'string') {
        $.countdown[`_${options}Countdown`].apply($.countdown, [this].concat(otherArgs));
      } else {
        $.countdown._attachCountdown(this, options);
      }
    });
  };

  /* Initialise the countdown functionality. */
  $.countdown = new Countdown(); // singleton instance
}(jQuery));

/**
 * Package: buildClock
 *
 * Description:
 * this file is the javascript to generate the watch.
 *
 * Files:
 *  - rolex-core-1.3.5.js
 *
 * License:
 * Copyright (c) 2012, matchbox France http://www.matchbox.fr
 * This program is dual licensed under the GNU General Public License
 * and Simplified BSD license.
 */
(function ($) {
  // image folder
  const imgFolder = 'img';
  if (Modernizr.retina == true) {
    // TODO
    //        imgFolder = "imgRetina";
  }

  // get hands images extension
  let imageExtension = 'png';
  if (Modernizr.svg == true) {
    imageExtension = 'svg';
  }

  /**
   * Build clock.
   * @param {object} options
   * @returns {undefined}
   */
  $.fn.rolexClock = function (options) {
    // default params
    let params = {
      // CONFIGS
      LANG: 'en', // Language
      contentWidth: 0, // px Width of the content
      contentHeight: 0, // px Height of the content
      flashname: '', // flash filename
      fallback: '', // image filename
      trackingurl: '',
      /* set the tracking url */
      leadingZeros: false, // Display with leading zero.
      amPm: false,
      /* set custom offset if city doesn't exist in the list */
      time24hours: true,
      /* show time in 24 hours format with true */
      showText: true,
      /* show/hide text and time */
      showTime: false,
      /* show time only without city */
      showDay: false,
      /* show day of a week */
      // CLOCKS
      clockWidth: 0,
      /* width of the clock to be set on top the html file */
      clockHeight: 0,
      /* height of the clock to be set on top the html file */
      globalXcenter: 0, // center of clock X
      globalYcenter: 0, // center of clock Y
      globalXscale: 0, // scale of clock X
      globalYscale: 0, // scale of clock Y
      handsFolder: '/blocks/ads/rolex/rolex/img/hands/green/', // assets folder
      watchContainerID: 'clock', // ID of watch container
      // hands parameters
      handsParams: {
        // imagetype SVG
        svg: {
          hour: { width: 9 },
          minute: { width: 9 },
          second: { width: 6, xrotation: 3 },
        },
        // imagetype PNG
        png: {
          hour: { width: 9 },
          minute: { width: 9 },
          second: { width: 6, xrotation: 3 },
        },
      },
      forceFlash: false,
      blockcontrollerVisible: false,
      forceFallback: false,
      clocktimeAtEvent: false, // Tells whether we display the time at the event location, defined in listofdates.js or not (not tested yet)
      isCountdownClock: false, // Whether it is a countdown. Defaults to false.
      countdownNumbersOnly: false, // Display only numbers in count
      onclickCity() {
        // callback here when "city" is clicked
      },
      onclickYourtime() {
        // callback here when "your time" is clicked
      },
      showDefaultCity: false, // Show the default city if no configurable city is currently active
      showLocalOnly: false, // Whether we show the local time only. Defaults to false.
      dateList: undefined, // List of date
      // COMPETITION
      isCompetitionWithCarousel: false, // Whether it's a competition. Defaults to false.
      competitionParams: { // Competition params.
        interval: 1000, // carousel interval in ms
        tag: 'div', // tagname used
      },
      // CLASSNAME
      blockClass: 'block', // default block class name
      activeClass: 'active', // active block class name
    };
    // methods
    const methods = {
      /**
       * Activate a block time.
       * args:
       * - ID of block
       */
      activeBlock() {
        if (typeof arguments[0] === 'string') {
          const target = $(`.block#${arguments[0]}`);
          if (target.length > 0) {
            target.trigger('click');
          }
        }
      },
    };
    const _competition = {
      index: -1, // index de dpart
      isAnimationActive: true,
      timer: undefined, // timer
      data: [], // event data
    };

    // options calls
    if (options && typeof options === 'string' && methods[options]) {
      return methods[options].apply(this, Array.prototype.slice.call(arguments, 1));
    } if (options && typeof options === 'object') {
      params = $.extend({}, params, options);
    }

    function init() {
      // init default event
      let defaultEvent;
      if (params.isCountdownClock) {
        defaultEvent = {
          city: 'GMT', // {string} city name
          local: 'Your Time', // {string} local text
          startDate: '19700101', // {string} start date yyyymmdd
          endDate: '99990101',
          offset: 0, // {float} Difference to Greenwich time (GMT) in hours. Ex: -4 for NYC, 5.3 for NewDelhi, 5.45 for Katmandu
          dst: 0, // {string} Daylight saving time zone
          cdtext: 'ROLEX COUNTDOWN', // CD text
          cdyear: '1970', // CD year
          cdmonth: '11', // CD month
          cdday: '29', // CD day
          cdhour: '09', // CD hour
          cdmin: '00', // CD min
        };
      } else {
        defaultEvent = {
          city: 'GMT', // {string} city name
          local: 'Your Time', // {string} local text
          startDate: '19700101', // {string} start date yyyymmdd
          endDate: '99990101', // {string} end date yyyymmdd
          offset: 0, // {float} Difference to Greenwich time (GMT) in hours. Ex: -4 for NYC, 5.3 for NewDelhi, 5.45 for Katmandu
          dst: 0, // {string} Daylight saving time zone
        };
      }

      // si compet, add new property
      if (params.isCompetitionWithCarousel) {
        defaultEvent.competition = {};
      }

      // Add default event.
      if (params.dateList === undefined) {
        params.dateList = [
          defaultEvent,
        ];
      } else {
        // push a default city
        params.dateList.push(defaultEvent);
      }
    }

    init();

    // if NO-JS, fallback static image is shown by default.
    // if JS, fallback static image is hidden and grid is shown.
    function showClock() {
      $('.ui-loader').hide();
      $('#fallback').hide();
      $('.content').show();
    }

    window.requestAnimFrame = (function () {
      return window.requestAnimationFrame
        || window.webkitRequestAnimationFrame
        || window.mozRequestAnimationFrame
        || window.oRequestAnimationFrame
        || window.msRequestAnimationFrame
        || function (callback) {
          window.setTimeout(callback, 1000 / 10);
        };
    }());

    const image_folder = params.handsFolder;
    const all_parts = new Array('hours', 'minutes', 'seconds', 'top_center');

    const hours_p = new Array();
    hours_p.url = `hours.${imageExtension}`;
    hours_p.update_mode = 'hours_base_12';
    hours_p.width = params.handsParams[imageExtension].hour.width;
    hours_p.height = 61;
    hours_p.xrotation = params.handsParams[imageExtension].hour.width / 2;
    hours_p.yrotation = 49;
    hours_p.xcenteroffset = 0;
    hours_p.ycenteroffset = 0;

    const minutes_p = new Array();
    minutes_p.url = `minutes.${imageExtension}`;
    minutes_p.update_mode = 'minutes_base_60';
    minutes_p.width = params.handsParams[imageExtension].minute.width;
    minutes_p.height = 75;
    minutes_p.xrotation = params.handsParams[imageExtension].minute.width / 2;
    minutes_p.yrotation = 60;
    minutes_p.xcenteroffset = 0;
    minutes_p.ycenteroffset = 0;

    const seconds_p = new Array();
    seconds_p.url = `seconds.${imageExtension}`;
    seconds_p.update_mode = 'seconds_base_60';
    seconds_p.width = params.handsParams[imageExtension].second.width;
    seconds_p.height = 92;
    seconds_p.xrotation = params.handsParams[imageExtension].second.xrotation;
    seconds_p.yrotation = 70;
    seconds_p.xcenteroffset = 0;
    seconds_p.ycenteroffset = 0;
    seconds_p.watch_x_center = 0;
    seconds_p.watch_y_center = 0;

    const top_center_p = new Array();
    top_center_p.url = 'center.png';
    top_center_p.width = 5;
    top_center_p.height = 5;
    top_center_p.xcenteroffset = -2.5;
    top_center_p.ycenteroffset = -7;

    const cyclop_mask_p = new Array();

    const global_watch_p = new Array();
    global_watch_p.rotation_angle = 0;
    global_watch_p.width = params.clockWidth;
    global_watch_p.height = params.clockHeight;
    global_watch_p.xscale = params.globalXscale;
    global_watch_p.yscale = params.globalYscale;

    function countProperties(a) {
      let b = 0;
      for (const c in a) {
        if (a.hasOwnProperty(c)) ++b;
      }
      return b;
    }
    //        function onImageLoaded(a) {
    /// /            console.log(all_p_to_be_loaded)
    //            all_p_to_be_loaded--;
    //            if (all_p_to_be_loaded == 0) {
    //            }
    //        }

    const partsContainer = document.createElement('div');
    partsContainer.style.position = 'absolute';
    partsContainer.style.width = '1px';
    partsContainer.style.height = '1px';
    partsContainer.style.padding = '0';
    partsContainer.style.margin = '-2px';
    partsContainer.style.overflow = 'hidden';
    partsContainer.style.clip = 'rect(0, 0, 0, 0)';
    partsContainer.style.border = '0';
    document.getElementsByTagName('body')[0].appendChild(partsContainer);

    /* load sprite */
    const loadSpriteErrors = [];

    function loadSprite(i, src) {
      //            console.log("i=" + i + "; src=" + src);
      const deferred = $.Deferred();
      all_p[i].image = document.createElement('img');
      all_p[i].image.id = `p_${all_parts[i]}`;
      all_p[i].image.onload = function () {
        deferred.resolve();
      };
      all_p[i].image.onerror = function () {
        loadSpriteErrors.push(src);
        $('.content').hide();
        $('.fallback').show();
      };
      partsContainer.appendChild(all_p[i].image);
      all_p[i].image.src = src;
      return deferred.promise();
    }
    var all_p = new Array();
    let all_p_to_be_loaded = all_parts.length;
    for (i = 0; i < all_parts.length; i++) {
      all_p[i] = eval(`${all_parts[i]}_p`);
    }
    const loaders = [];
    for (var i = 0; i < all_parts.length; i++) {
      if (all_p[i].url != null) {
        // loads img
        loaders.push(loadSprite(i, image_folder + all_p[i].url));
        if (!all_p[i].fileformat) {
          all_p[i].fileformat = all_p[i].url.substring(all_p[i].url.length - 3, all_p[i].url.length);
        }
      } else {
        all_p_to_be_loaded--;
      }
      if (!all_p[i].xcenteroffset) {
        all_p[i].xcenteroffset = 0;
      }
      if (!all_p[i].ycenteroffset) {
        all_p[i].ycenteroffset = 0;
      }
      if (!all_p[i].xoriginoffset) {
        all_p[i].xoriginoffset = null;
      }
      if (!all_p[i].yoriginoffset) {
        all_p[i].yoriginoffset = null;
      }
      if (!all_p[i].xcenter) {
        all_p[i].xcenter = 0;
      }
      if (!all_p[i].ycenter) {
        all_p[i].ycenter = 0;
      }
      if (!all_p[i].update_mode) {
        all_p[i].update_mode = null;
      }
      if (!all_p[i].watch_x_center) {
        all_p[i].offset_alternate_x_center = 0;
      } else {
        all_p[i].offset_alternate_x_center = global_watch_p[all_p[i].watch_x_center] - global_watch_p.xcenter;
      }
      if (!all_p[i].watch_y_center) {
        all_p[i].offset_alternate_y_center = -4;
      } else {
        all_p[i].offset_alternate_y_center = global_watch_p[all_p[i].watch_y_center] - global_watch_p.ycenter;
      }
    }

    /* load simultaneously all sprites */
    $.when.apply(null, loaders).done(() => {
      // callback when everything was loaded
      all_p_to_be_loaded -= loaders.length; // decrement the number of images to load.
    });

    function f_calculate_additional_vars() {
      if (GLOBAL_LIGHT_SOURCE != undefined) {
        TOP_LIGHT_START = GLOBAL_LIGHT_SOURCE - 90;
        TOP_LIGHT_END = GLOBAL_LIGHT_SOURCE + 90;
        BOTTOM_LIGHT_START = GLOBAL_LIGHT_SOURCE - 90;
        BOTTOM_LIGHT_END = GLOBAL_LIGHT_SOURCE + 90;
        TOP_SHADE_START = GLOBAL_LIGHT_SOURCE + 90;
        TOP_SHADE_END = GLOBAL_LIGHT_SOURCE - 90;
        BOTTOM_SHADE_START = GLOBAL_LIGHT_SOURCE + 90;
        BOTTOM_SHADE_END = GLOBAL_LIGHT_SOURCE - 90;
        LEFT_LIGHT_START = GLOBAL_LIGHT_SOURCE;
        LEFT_LIGHT_END = GLOBAL_LIGHT_SOURCE + 180;
        RIGHT_LIGHT_START = GLOBAL_LIGHT_SOURCE + 180;
        RIGHT_LIGHT_END = GLOBAL_LIGHT_SOURCE;
        LEFT_SHADE_START = GLOBAL_LIGHT_SOURCE + 180;
        LEFT_SHADE_END = GLOBAL_LIGHT_SOURCE;
        RIGHT_SHADE_START = GLOBAL_LIGHT_SOURCE;
        RIGHT_SHADE_END = GLOBAL_LIGHT_SOURCE + 180;
      }
      if (GLOBAL_MIN_ALPHA != undefined) {
        TOP_LIGHT_MIN = BOTTOM_LIGHT_MIN = TOP_SHADE_MIN = BOTTOM_SHADE_MIN = LEFT_LIGHT_MIN = RIGHT_LIGHT_MIN = LEFT_SHADE_MIN = RIGHT_SHADE_MIN = GLOBAL_MIN_ALPHA;
      }
      if (GLOBAL_MAX_ALPHA != undefined) {
        TOP_LIGHT_MAX = BOTTOM_LIGHT_MAX = TOP_SHADE_MAX = BOTTOM_SHADE_MAX = LEFT_LIGHT_MAX = RIGHT_LIGHT_MAX = LEFT_SHADE_MAX = RIGHT_SHADE_MAX = GLOBAL_MAX_ALPHA;
      }
      while (TOP_LIGHT_START > TOP_LIGHT_END) {
        TOP_LIGHT_END += 360;
      }
      while (BOTTOM_LIGHT_START > BOTTOM_LIGHT_END) {
        BOTTOM_LIGHT_END += 360;
      }
      while (TOP_SHADE_START > TOP_SHADE_END) {
        TOP_SHADE_END += 360;
      }
      while (BOTTOM_SHADE_START > BOTTOM_SHADE_END) {
        BOTTOM_SHADE_END += 360;
      }
      while (LEFT_LIGHT_START > LEFT_LIGHT_END) {
        LEFT_LIGHT_END += 360;
      }
      while (RIGHT_LIGHT_START > RIGHT_LIGHT_END) {
        RIGHT_LIGHT_END += 360;
      }
      while (LEFT_SHADE_START > LEFT_SHADE_END) {
        LEFT_SHADE_END += 360;
      }
      while (RIGHT_SHADE_START > RIGHT_SHADE_END) {
        RIGHT_SHADE_END += 360;
      }
      while (TOP_LIGHT_END > 360) {
        TOP_LIGHT_START -= 360;
        TOP_LIGHT_END -= 360;
      }
      while (BOTTOM_LIGHT_END > 360) {
        BOTTOM_LIGHT_START -= 360;
        BOTTOM_LIGHT_END -= 360;
      }
      while (TOP_SHADE_END > 360) {
        TOP_SHADE_START -= 360;
        TOP_SHADE_END -= 360;
      }
      while (BOTTOM_SHADE_END > 360) {
        BOTTOM_SHADE_START -= 360;
        BOTTOM_SHADE_END -= 360;
      }
      while (LEFT_LIGHT_END > 360) {
        LEFT_LIGHT_START -= 360;
        LEFT_LIGHT_END -= 360;
      }
      while (RIGHT_LIGHT_END > 360) {
        RIGHT_LIGHT_START -= 360;
        RIGHT_LIGHT_END -= 360;
      }
      while (LEFT_SHADE_END > 360) {
        LEFT_SHADE_START -= 360;
        LEFT_SHADE_END -= 360;
      }
      while (RIGHT_SHADE_END > 360) {
        RIGHT_SHADE_START -= 360;
        RIGHT_SHADE_END -= 360;
      }
      if (TOP_LIGHT_START < TOP_LIGHT_END) {
        top_light_max_point = (TOP_LIGHT_START + TOP_LIGHT_END) / 2 % 360;
        top_light_range = TOP_LIGHT_END - TOP_LIGHT_START;
      } else {
        top_light_max_point = (TOP_LIGHT_START + TOP_LIGHT_END) % 360 / 2;
        top_light_range = 360 + TOP_LIGHT_END - TOP_LIGHT_START;
      }
      top_light_mid_range = top_light_range / 2;
      if (BOTTOM_LIGHT_START < BOTTOM_LIGHT_END) {
        bottom_light_max_point = (BOTTOM_LIGHT_START + BOTTOM_LIGHT_END) / 2 % 360;
        bottom_light_range = BOTTOM_LIGHT_END - BOTTOM_LIGHT_START;
      } else {
        bottom_light_max_point = (BOTTOM_LIGHT_START + BOTTOM_LIGHT_END) % 360 / 2;
        bottom_light_range = 360 + BOTTOM_LIGHT_END - BOTTOM_LIGHT_START;
      }
      bottom_light_mid_range = bottom_light_range / 2;
      if (TOP_SHADE_START < TOP_SHADE_END) {
        top_shade_max_point = (TOP_SHADE_START + TOP_SHADE_END) / 2 % 360;
        top_shade_range = TOP_SHADE_END - TOP_SHADE_START;
      } else {
        top_shade_max_point = (TOP_SHADE_START + TOP_SHADE_END) % 360 / 2;
        top_shade_range = 360 + TOP_SHADE_END - TOP_SHADE_START;
      }
      top_shade_mid_range = top_shade_range / 2;
      if (BOTTOM_SHADE_START < BOTTOM_SHADE_END) {
        bottom_shade_max_point = (BOTTOM_SHADE_START + BOTTOM_SHADE_END) / 2 % 360;
        bottom_shade_range = BOTTOM_SHADE_END - BOTTOM_SHADE_START;
      } else {
        bottom_shade_max_point = (BOTTOM_SHADE_START + BOTTOM_SHADE_END) % 360 / 2;
        bottom_shade_range = 360 + BOTTOM_SHADE_END - BOTTOM_SHADE_START;
      }
      bottom_shade_mid_range = bottom_shade_range / 2;
      if (LEFT_LIGHT_START < LEFT_LIGHT_END) {
        left_light_max_point = (LEFT_LIGHT_START + LEFT_LIGHT_END) / 2 % 360;
        left_light_range = LEFT_LIGHT_END - LEFT_LIGHT_START;
      } else {
        left_light_max_point = (LEFT_LIGHT_START + LEFT_LIGHT_END) % 360 / 2;
        left_light_range = 360 + LEFT_LIGHT_END - LEFT_LIGHT_START;
      }
      left_light_mid_range = left_light_range / 2;
      if (RIGHT_LIGHT_START < RIGHT_LIGHT_END) {
        right_light_max_point = (RIGHT_LIGHT_START + RIGHT_LIGHT_END) / 2 % 360;
        right_light_range = RIGHT_LIGHT_END - RIGHT_LIGHT_START;
      } else {
        right_light_max_point = (RIGHT_LIGHT_START + RIGHT_LIGHT_END) % 360 / 2;
        right_light_range = 360 + RIGHT_LIGHT_END - RIGHT_LIGHT_START;
      }
      right_light_mid_range = right_light_range / 2;
      if (LEFT_SHADE_START < LEFT_SHADE_END) {
        left_shade_max_point = (LEFT_SHADE_START + LEFT_SHADE_END) / 2 % 360;
        left_shade_range = LEFT_SHADE_END - LEFT_SHADE_START;
      } else {
        left_shade_max_point = (LEFT_SHADE_START + LEFT_SHADE_END) % 360 / 2;
        left_shade_range = 360 + LEFT_SHADE_END - LEFT_SHADE_START;
      }
      left_shade_mid_range = left_shade_range / 2;
      if (RIGHT_SHADE_START < RIGHT_SHADE_END) {
        right_shade_max_point = (RIGHT_SHADE_START + RIGHT_SHADE_END) / 2 % 360;
        right_shade_range = RIGHT_SHADE_END - RIGHT_SHADE_START;
      } else {
        right_shade_max_point = (RIGHT_SHADE_START + RIGHT_SHADE_END) % 360 / 2;
        right_shade_range = 360 + RIGHT_SHADE_END - RIGHT_SHADE_START;
      }
      right_shade_mid_range = right_shade_range / 2;
    }

    function getAlphaForRotation(a, b, c) {
      b = 180 * b / Math.PI + 90;
      subf_find_distance_to_max_point = function (a) {
        let c = Math.abs(a - b);
        if (c > 180) {
          c = Math.abs(180 - (c - 180));
        }
        return c;
      };
      let d;
      if (a == 'top_light') {
        if (c == 'reverse') {
          this_hand_distance_to_top_light_point = subf_find_distance_to_max_point(-top_light_max_point);
        } else {
          this_hand_distance_to_top_light_point = subf_find_distance_to_max_point(top_light_max_point);
        }
        if (this_hand_distance_to_top_light_point <= top_light_mid_range) {
          d = TOP_LIGHT_MIN + (1 - this_hand_distance_to_top_light_point / top_light_mid_range) * (TOP_LIGHT_MAX - TOP_LIGHT_MIN);
        } else {
          d = TOP_LIGHT_MIN;
        }
      } else if (a == 'bottom_light') {
        if (c == 'reverse') {
          this_hand_distance_to_bottom_light_point = subf_find_distance_to_max_point(-bottom_light_max_point);
        } else {
          this_hand_distance_to_bottom_light_point = subf_find_distance_to_max_point(bottom_light_max_point);
        }
        if (180 - this_hand_distance_to_bottom_light_point <= bottom_light_mid_range) {
          d = BOTTOM_LIGHT_MIN + (1 - (180 - this_hand_distance_to_bottom_light_point) / bottom_light_mid_range) * (BOTTOM_LIGHT_MAX - BOTTOM_LIGHT_MIN);
        } else {
          d = BOTTOM_LIGHT_MIN;
        }
      } else if (a == 'top_shade') {
        if (c == 'reverse') {
          this_hand_distance_to_top_shade_point = subf_find_distance_to_max_point(-top_shade_max_point);
        } else {
          this_hand_distance_to_top_shade_point = subf_find_distance_to_max_point(top_shade_max_point);
        }
        if (this_hand_distance_to_top_shade_point <= top_shade_mid_range) {
          d = TOP_SHADE_MIN + (1 - this_hand_distance_to_top_shade_point / top_shade_mid_range) * (TOP_SHADE_MAX - TOP_SHADE_MIN);
        } else {
          d = TOP_SHADE_MIN;
        }
      } else if (a == 'bottom_shade') {
        if (c == 'reverse') {
          this_hand_distance_to_bottom_shade_point = subf_find_distance_to_max_point(-bottom_shade_max_point);
        } else {
          this_hand_distance_to_bottom_shade_point = subf_find_distance_to_max_point(bottom_shade_max_point);
        }
        if (180 - this_hand_distance_to_bottom_shade_point <= bottom_shade_mid_range) {
          d = BOTTOM_SHADE_MIN + (1 - (180 - this_hand_distance_to_bottom_shade_point) / bottom_shade_mid_range) * (BOTTOM_SHADE_MAX - BOTTOM_SHADE_MIN);
        } else {
          d = BOTTOM_SHADE_MIN;
        }
      }
      if (c == 'reverse') {
        if (a == 'left_light') {
          this_hand_distance_to_left_light_point = subf_find_distance_to_max_point(-left_light_max_point);
          if (this_hand_distance_to_left_light_point <= left_light_mid_range) {
            d = LEFT_LIGHT_MIN + (1 - this_hand_distance_to_left_light_point / left_light_mid_range) * (LEFT_LIGHT_MAX - LEFT_LIGHT_MIN);
          } else {
            d = LEFT_LIGHT_MIN;
          }
        } else if (a == 'right_light') {
          if (this_hand_distance_to_right_light_point <= right_light_mid_range) {
            d = RIGHT_LIGHT_MIN + (1 - this_hand_distance_to_right_light_point / right_light_mid_range) * (RIGHT_LIGHT_MAX - RIGHT_LIGHT_MIN);
          } else {
            d = RIGHT_LIGHT_MIN;
          }
        } else if (a == 'left_shade') {
          this_hand_distance_to_left_shade_point = subf_find_distance_to_max_point(-left_shade_max_point);
          if (this_hand_distance_to_left_shade_point <= left_shade_mid_range) {
            d = (1 - this_hand_distance_to_left_shade_point / left_shade_mid_range) * (LEFT_SHADE_MAX - LEFT_SHADE_MIN);
          } else {
            d = LEFT_SHADE_MIN;
          }
        } else if (a == 'right_shade') {
          this_hand_distance_to_right_shade_point = subf_find_distance_to_max_point(-right_shade_max_point);
          if (this_hand_distance_to_right_shade_point <= right_shade_mid_range) {
            d = (1 - this_hand_distance_to_right_shade_point / right_shade_mid_range) * (RIGHT_SHADE_MAX - RIGHT_SHADE_MIN);
          } else {
            d = RIGHT_SHADE_MIN;
          }
        }
      } else if (a == 'left_light') {
        this_hand_distance_to_left_light_point = subf_find_distance_to_max_point(left_light_max_point);
        if (this_hand_distance_to_left_light_point <= left_light_mid_range) {
          d = LEFT_LIGHT_MIN + (1 - this_hand_distance_to_left_light_point / left_light_mid_range) * (LEFT_LIGHT_MAX - LEFT_LIGHT_MIN);
        } else {
          d = LEFT_LIGHT_MIN;
        }
      } else if (a == 'right_light') {
        this_hand_distance_to_right_light_point = subf_find_distance_to_max_point(-right_light_max_point);
        this_hand_distance_to_right_light_point = subf_find_distance_to_max_point(right_light_max_point);
        if (this_hand_distance_to_right_light_point <= right_light_mid_range) {
          d = RIGHT_LIGHT_MIN + (1 - this_hand_distance_to_right_light_point / right_light_mid_range) * (RIGHT_LIGHT_MAX - RIGHT_LIGHT_MIN);
        } else {
          d = RIGHT_LIGHT_MIN;
        }
      } else if (a == 'left_shade') {
        this_hand_distance_to_left_shade_point = subf_find_distance_to_max_point(left_shade_max_point);
        if (this_hand_distance_to_left_shade_point <= left_shade_mid_range) {
          d = LEFT_SHADE_MIN + (1 - this_hand_distance_to_left_shade_point / left_shade_mid_range) * (LEFT_SHADE_MAX - LEFT_SHADE_MIN);
        } else {
          d = LEFT_SHADE_MIN;
        }
      } else if (a == 'right_shade') {
        this_hand_distance_to_right_shade_point = subf_find_distance_to_max_point(right_shade_max_point);
        if (this_hand_distance_to_right_shade_point <= right_shade_mid_range) {
          d = RIGHT_SHADE_MIN + (1 - this_hand_distance_to_right_shade_point / right_shade_mid_range) * (RIGHT_SHADE_MAX - RIGHT_SHADE_MIN);
        } else {
          d = RIGHT_SHADE_MIN;
        }
      }
      return d / 100;
    }
    var GLOBAL_LIGHT_SOURCE = 360;
    var GLOBAL_MIN_ALPHA = 0;
    var GLOBAL_MAX_ALPHA = 100;
    var TOP_LIGHT_START = 0;
    var TOP_LIGHT_END = 0;
    var BOTTOM_LIGHT_START = 0;
    var BOTTOM_LIGHT_END = 0;
    var TOP_SHADE_START = 0;
    var TOP_SHADE_END = 0;
    var BOTTOM_SHADE_START = 0;
    var BOTTOM_SHADE_END = 0;
    var LEFT_LIGHT_START = 0;
    var LEFT_LIGHT_END = 0;
    var RIGHT_LIGHT_START = 0;
    var RIGHT_LIGHT_END = 0;
    var LEFT_SHADE_START = 0;
    var LEFT_SHADE_END = 0;
    var RIGHT_SHADE_START = 0;
    var RIGHT_SHADE_END = 0;
    var TOP_LIGHT_MIN = 0;
    var TOP_LIGHT_MAX = 0;
    var BOTTOM_LIGHT_MIN = 0;
    var BOTTOM_LIGHT_MAX = 0;
    var TOP_SHADE_MIN = 0;
    var TOP_SHADE_MAX = 0;
    var BOTTOM_SHADE_MIN = 0;
    var BOTTOM_SHADE_MAX = 0;
    var LEFT_LIGHT_MIN = 0;
    var LEFT_LIGHT_MAX = 0;
    var RIGHT_LIGHT_MIN = 0;
    var RIGHT_LIGHT_MAX = 0;
    var LEFT_SHADE_MIN = 0;
    var LEFT_SHADE_MAX = 0;
    var RIGHT_SHADE_MIN = 0;
    var RIGHT_SHADE_MAX = 0;
    var top_light_max_point = 0;
    var top_light_range = 0;
    var top_light_mid_range = 0;
    var bottom_light_max_point = 0;
    var bottom_light_range = 0;
    var bottom_light_mid_range = 0;
    var top_shade_max_point = 0;
    var top_shade_range = 0;
    var top_shade_mid_range = 0;
    var bottom_shade_max_point = 0;
    var bottom_shade_range = 0;
    var bottom_shade_mid_range = 0;
    f_calculate_additional_vars();
    let updated;

    function getHiddenProp() {
      const prefixes = ['webkit', 'moz', 'ms', 'o'];

      // if 'hidden' is natively supported just return it
      if ('hidden' in document) return 'hidden';

      // otherwise loop over all the known prefixes until we find one
      for (let i = 0; i < prefixes.length; i++) {
        if ((`${prefixes[i]}Hidden`) in document) return `${prefixes[i]}Hidden`;
      }

      // otherwise it's not supported
      return null;
    }

    function isHidden() {
      const prop = getHiddenProp();
      if (!prop) return false;

      return document[prop];
    }
    const visProp = getHiddenProp();
    if (visProp) {
      const evtname = `${visProp.replace(/[H|h]idden/, '')}visibilitychange`;
      document.addEventListener(evtname, visChange);
    }

    function visChange() {
      if (isHidden()) updated = false;
      else updateTime();
    }

    // self.onblur = function() { updated = false; }
    // self.onfocus = function() { updateTime() }

    function updateTime() {
      if (params.isCountdownClock) {
        if (updated == true) {
          current_seconds += 1000 / 10;

          if (current_seconds >= 60) {
            // console.log(current_seconds)
            currentTime = new Date();
            currentTime.setHours(currentTime.getHours() + hoursOffset);
            currentTime.setMinutes(currentTime.getMinutes() + minutesOffset);
            currentTime.setSeconds(currentTime.getSeconds() + secondsOffset);
            current_hours = currentTime.getHours();
            current_minutes = currentTime.getMinutes();
            current_seconds = currentTime.getSeconds();
            current_milliseconds = currentTime.getMilliseconds();
          }
          // console.log(currentTime)
        } else {
          currentTime = new Date();
          // console.log(current_seconds)
          currentTime.setHours(currentTime.getHours() + hoursOffset);
          currentTime.setMinutes(currentTime.getMinutes() + minutesOffset);
          currentTime.setSeconds(currentTime.getSeconds() + secondsOffset);
          monthdate = currentTime.getDate(); // n du jour local: 0..31
          weekday_num = currentTime.getDay(); // jour de la semaine local: 0=> sun, ..., 6=> sat
          current_hours = currentTime.getHours();
          current_minutes = currentTime.getMinutes();
          current_seconds = currentTime.getSeconds();
          current_milliseconds = currentTime.getMilliseconds();
          // console.log(current_seconds,currentTime.getMilliseconds())
          // console.log(monthdate,weekday_num,current_hours,current_minutes,current_seconds)
          updated = true;
        }
      } else {
        currentTime = new Date();
        currentTime.setHours(currentTime.getHours() + hoursOffset);
        currentTime.setMinutes(currentTime.getMinutes() + minutesOffset);
        currentTime.setSeconds(currentTime.getSeconds() + secondsOffset);
        monthdate = currentTime.getDate();
        weekday_num = currentTime.getDay();
        current_seconds = currentTime.getSeconds();
        current_minutes = currentTime.getMinutes();
        current_hours = currentTime.getHours();
        current_milliseconds = currentTime.getMilliseconds();
      }
    }

    function setTimeToDefaultTime() {
      currentTime = new Date();
      currentTime.setHours(10);
      currentTime.setMinutes(11);
      currentTime.setSeconds(31);
      monthdate = currentTime.getDate();
      weekday_num = currentTime.getDay();
      current_seconds = currentTime.getSeconds();
      current_minutes = currentTime.getMinutes();
      current_hours = currentTime.getHours();
      current_milliseconds = currentTime.getMilliseconds();
    }

    function updateTimeCalculations() {
      let a = current_hours;
      weekday_num++;
      if (a > 12) {
        a -= 12;
      }
      display_calculation.seconds_base_60 = current_seconds * timeSlice;
      display_calculation.seconds_base_60 += current_milliseconds * timeSlice / 1e3;
      display_calculation.seconds_base_60 += rotCorrect;
      display_calculation.minutes_base_60 = current_minutes * timeSlice;
      display_calculation.minutes_base_60 += current_seconds * timeSlice / 60;
      display_calculation.minutes_base_60 += rotCorrect;
      display_calculation.minutes_base_30 = current_minutes * timeSlice * 2;
      display_calculation.minutes_base_30 += current_seconds * timeSlice * 2 / 60;
      display_calculation.minutes_base_30 += rotCorrect;
      display_calculation.hours_base_12 = a * timeSlice * 5;
      display_calculation.hours_base_12 += current_minutes * timeSlice / 12;
      display_calculation.hours_base_12 += rotCorrect;
      display_calculation.monthdate_base_31 = monthdate * (timeSlice / 6) * (360 / 31);
      display_calculation.monthdate_base_31 += rotCorrect;
    }

    function easeInOutQuad(a, b, c, d) {
      if (a < d / 2) return 2 * c * a * a / (d * d) + b;
      ts = a - d / 2;
      return -2 * c * ts * ts / (d * d) + 2 * c * ts / d + c / 2 + b;
    }

    function setHoursOffset(a) {
      hoursOffset = a;
    }

    function setMinutesOffset(a) {
      minutesOffset = a;
    }

    function setSecondsOffset(a) {
      secondsOffset = a;
    }

    function getCurrentShownTime() {
      let a = '';
      if (current_hours < 10) {
        a += '0';
      }
      a += current_hours;
      a += ':';
      if (current_minutes < 10) {
        a += '0';
      }
      a += current_minutes;
      return a;
    }

    function updateOnTimeDisplayOnce() {
      updateTimeCalculations();
      updateDisplay();
    }

    function updateOnTimeDisplayOvertime() {
      updateTime();
      updateOnTimeDisplayOnce();
      timeoutID = window.setTimeout(updateOnTimeDisplayOvertime, tickDelay);
    }
    const ticks_per_seconds = 10;
    let parts_starting_z_index = 23;
    var tickDelay = 1e3 / ticks_per_seconds;
    var timeSlice = Math.PI * 2 / 60;
    var rotCorrect = global_watch_p.rotation_angle * (timeSlice / 6);
    var display_calculation = new Array();
    var currentTime = null;
    var hoursOffset = 0;
    var minutesOffset = 0;
    var secondsOffset = 0;
    var monthdate = null;
    var weekday_num = null;
    var current_seconds = null;
    var current_minutes = null;
    var current_hours = null;
    var current_milliseconds = null;
    const canvasId = 'regular_timepiece_canvas';
    const watchContainer = params.watchContainerID;
    const canvasParent = document.getElementById(canvasId);

    function prepareTimepieceElements() {
      if (prepareTimepieceElementsIsDone == false) {
        for (i = 0; i < all_parts.length; i++) {
          if (all_p[i].update_mode == 'monthdate' || all_p[i].update_mode == 'weekday') {
            if (all_p[i].url == null) {
              var a = document.createElement('DIV');
            } else {
              var a = document.createElement('CANVAS');
            }
            document.getElementById(watchContainer).appendChild(a);
            if (typeof G_vmlCanvasManager !== 'undefined') {
              a = G_vmlCanvasManager.initElement(a);
            }
            a.setAttribute('id', `${all_parts[i]}_div`);
            a.style.position = 'absolute';
            a.style.width = `${all_p[i].width}px`;
            a.style.height = `${all_p[i].height}px`;
            a.style.left = `${all_p[i].xoriginoffset}px`;
            a.style.top = `${all_p[i].yoriginoffset}px`;
            if (all_p[i].url == null) {
              a.style.color = `#${all_p[i].txt_color}`;
              a.style.fontSize = all_p[i].txt_fontSize;
              a.style.fontFamily = 'Arial';
              a.style.textAlign = 'center';
            }
            parts_starting_z_index += i;
            a.style.zIndex = parts_starting_z_index;
          }
        }
        var b = document.createElement('CANVAS');
        document.getElementById(watchContainer).appendChild(b);
        if (typeof G_vmlCanvasManager !== 'undefined') {
          b = G_vmlCanvasManager.initElement(b);
        }
        b.setAttribute('id', 'regular_timepiece_canvas');
        b.style.position = 'absolute';
        b.setAttribute('width', global_watch_p.width);
        b.setAttribute('height', global_watch_p.height);
        b.style.zIndex = parts_starting_z_index;
        if (cyclop_mask_p.url) {
          var b = document.createElement('CANVAS');
          document.getElementById(watchContainer).appendChild(b);
          if (typeof G_vmlCanvasManager !== 'undefined') {
            b = G_vmlCanvasManager.initElement(b);
          }
          b.setAttribute('id', 'magnified_timepiece_canvas');
          b.style.position = 'absolute';
          b.setAttribute('width', global_watch_p.width);
          b.setAttribute('height', global_watch_p.height);
          b.style.zIndex = parts_starting_z_index + 1;
        }
        prepareTimepieceElementsIsDone = true;
      }
    }

    function placeCanvas(a, b, c) {
      a.clearRect(-global_watch_p.width, -global_watch_p.height, global_watch_p.width * 2, global_watch_p.height * 2);
      if (b == false) {} else {
        a.save();
        if (c) {
          a.translate(global_watch_p[c.watch_x_center], global_watch_p[c.watch_y_center]);
        } else {
          a.translate(global_watch_p.xcenter, global_watch_p.ycenter);
        }
      }
    }

    function updateDisplay() {
      if (cyclop_mask_p.url) {
        var a = document.getElementById(canvasId);
        var b = a.getContext('2d');
        placeCanvas(b, true);
        drawTimepiece(b, true);
        b.save();
        b.translate(-global_watch_p.xcenter, -global_watch_p.ycenter);
        b.globalCompositeOperation = 'destination-in';
        b.drawImage(cyclop_mask_p.image, 0, 0, cyclop_mask_p.width, cyclop_mask_p.height);
        b.restore();
        b.restore();
      }
      var a = document.getElementById(canvasId);
      if (a.getContext) {
        var b = a.getContext('2d');
        placeCanvas(b, true);
        drawTimepiece(b, false);
        if (cyclop_mask_p.url) {
          b.save();
          b.translate(-global_watch_p.xcenter, -global_watch_p.ycenter);
          b.globalCompositeOperation = 'destination-out';
          b.drawImage(cyclop_mask_p.image, 0, 0, cyclop_mask_p.width, cyclop_mask_p.height);
          b.restore();
        }
        b.restore();
      } else {
        alert('no context');
      }
    }

    function drawTimepiece(a, b) {
      magnify_x_offset = 0;
      magnify_y_offset = 0;
      magnify_x_scale = 1;
      magnify_y_scale = 1;
      if (b == true) {
        magnify_x_offset = cyclop_mask_p.xcenteroffset;
        magnify_y_offset = cyclop_mask_p.ycenteroffset;
        magnify_x_scale = cyclop_mask_p.xscale;
        magnify_y_scale = cyclop_mask_p.yscale;
      }
      a.globalCompositeOperation = 'source-over';
      for (let i = 0; i < all_parts.length; i++) {
        const c = all_p[i];
        a.save();
        if (all_p[i].update_mode != null) {
          if (all_p[i].update_mode == 'monthdate') {
            if (all_p[i].url == null) {
              document.getElementById(`${all_parts[i]}_div`).innerHTML = monthdate;
            } else {
              document.getElementById(`${all_parts[i]}_div`).style.background = `url('${image_folder}num_${monthdate}.${all_p[i].fileformat}')`;
            }
          } else if (all_p[i].update_mode == 'weekday') {
            document.getElementById(`${all_parts[i]}_div`).style.background = `url('${image_folder}weekday_${weekday_num}.${all_p[i].fileformat}')`;
          } else {
            a.translate(c.xcenteroffset, c.ycenteroffset);
            a.translate(magnify_x_offset, magnify_y_offset);
            a.translate(c.offset_alternate_x_center, c.offset_alternate_y_center);
            a.scale(global_watch_p.xscale * magnify_x_scale, global_watch_p.yscale * magnify_y_scale);
            a.rotate(display_calculation[c.update_mode]);
            a.translate(-c.xrotation, -c.yrotation);

            //                        var img = c["image"];
            //                        console.log(img, c["width"],c["height"])
            const img = document.getElementById(`p_${all_parts[i]}`);
            //                        console.log("p_" + all_parts[i]);
            //                        canvas = document.getElementById(canvasId)
            //                        ctx = canvas.getContext('2d')
            //                        ctx.drawImage(img, 0, 0, c["width"], c["height"]);
            a.drawImage(img, 0, 0, c.width, c.height);
            for (const d in all_p[i].__lightEffects) {
              if (all_p[i].__lightEffects[d].height > 0) {
                a.globalAlpha = getAlphaForRotation(d, display_calculation[c.update_mode], 'normal');
                a.drawImage(c.__lightEffects[d], 0, 0, c.width, c.height);
              }
            }
          }
        } else {
          a.translate(all_p[i].xcenteroffset, all_p[i].ycenteroffset);
          a.translate(-all_p[i].xcenter, -all_p[i].ycenter);
          a.drawImage(all_p[i].image, 0, 0, all_p[i].width, all_p[i].height);
        }
        a.restore();
      }
    }

    function startWatchEngineWhenReady() {
      if (all_p_to_be_loaded < 1) {
        prepareTimepieceElements();
        //                updateOnTimeDisplayOvertime();
        window.setTimeout(updateOnTimeDisplayOvertime, 0);
      } else {
        requestAnimFrame(startWatchEngineWhenReady);
      }
    }

    function startWatchEngine() {
      //            if (window.addEventListener) {
      //                window.addEventListener("load", function() {
      startWatchEngineWhenReady();
      //                }, false)
      //            } else if (window.attachEvent) {
      //                window.attachEvent("onload", function() {
      //                    startWatchEngineWhenReady()
      //                })
      //            }
    }

    function showStaticWatchOnTime() {
      if (all_p_to_be_loaded < 1) {
        prepareTimepieceElements();
        setTimeToDefaultTime();
        updateOnTimeDisplayOnce();
      } else {
        timeoutID = window.setTimeout(showStaticWatchOnTime, tickDelay);
      }
    }

    function spinToCurrentTimeAfterDelay(a) {}
    var prepareTimepieceElementsIsDone = false;
    const weekday_displayed = false;
    var magnify_x_offset = 0;
    var magnify_y_offset = 0;

    const blockLocal = document.getElementById('yourtime');
    const blockCity = document.getElementById('city');

    let oldIE;
    if ($('html').is('.ie6, .ie7, .ie8, .ie9')) {
      oldIE = true;
    }

    /* vars for countdown  */
    const liftoffTime = new Date();
    liftoffTime.setDate(liftoffTime.getDate());
    let rolexClockCountdownCalc;

    function removeElement(id) {
      const element = document.getElementById(id);
      element.parentNode.removeChild(element);
    }

    function loadListofdates() {
      var language = params.LANG;
      var language = language.toLowerCase();
      const now_date = new Date();

      const year = now_date.getFullYear();
      let month = now_date.getMonth() + 1;
      let day = now_date.getDate();
      if (month < 10) {
        month = `0${month}`;
      }
      if (day < 10) {
        day = `0${day}`;
      }

      const names = [];
      const timezones = [];
      const timezone_dst = [];
      const timeText = [];

      const cdYear = [];
      const cdMonth = [];
      const cdDay = [];
      const cdHour = [];
      const cdMin = [];
      const ClockRacetext = [];

      const todayfull = Number(`${year}${month}${day}`);
      let index = null;
      for (let i = 0; i < params.dateList.length; i++) {
        if (todayfull >= params.dateList[i].startDate && todayfull <= params.dateList[i].endDate) {
          index = i;
          if (language == '' || i == params.dateList.length - 1) {
            names.push(params.dateList[index].city);
            timeText.push(params.dateList[index].local);
          } else {
            names.push(params.dateList[index].city);
            timeText.push(params.dateList[index].local);
          }
          timezones.push(params.dateList[index].offset);
          timezone_dst.push(params.dateList[index].dst);

          if (params.isCountdownClock) {
            cdYear.push(params.dateList[index].cdyear);
            cdMonth.push(params.dateList[index].cdmonth);
            cdDay.push(params.dateList[index].cdday);
            cdHour.push(params.dateList[index].cdhour);
            cdMin.push(params.dateList[index].cdmin);

            ClockRacetext.push(params.dateList[index].cdtext);
          }

          if (params.isCompetitionWithCarousel) {
            _competition.data.push(params.dateList[index]);
          }
        }
      }

      return {
        names,
        timezones,
        timezone_dst,
        timeText,
        cdYear,
        cdMonth,
        cdDay,
        cdHour,
        cdMin,
        ClockRacetext,
      };
    }
    // Update the competition module
    const competitionBlock = document.getElementById('competition');

    function updateCompetition() {
      if (_competition.isAnimationActive) { // si animation toujours active, on rappel
        const index = _competition.index >= (_competition.data.length - 2) ? 0 : _competition.index + 1; // -2 because of default element GMT.
        // pour chaque propriete, on update cre les lments
        const cur = _competition.data[index]; // si le suivant existe
        if (cur) {
          _competition.index = index;
          // removing any child nodes
          while (competitionBlock.lastChild) {
            competitionBlock.removeChild(competitionBlock.lastChild);
          }
          // update texts
          //                    console.log(cur);
          const c = cur.competition;
          for (const n in c) {
            const e = document.createElement(params.competitionParams.tag);
            e.className = `competition-${n}`;
            e.innerHTML = c[n];
            competitionBlock.appendChild(e);
          }

          updateClock(cur);
          updateAllTextBlock();

          _competition.timer = window.setTimeout(updateCompetition, params.competitionParams.interval);
        }
      }
    }
    // Activate/Desactivate animation. Defaults to FALSE.
    function activateCompetition(flag) {
      flag = (typeof flag === 'boolean') ? flag : false;
      _competition.isAnimationActive = flag;
    }
    // Update clock
    function updateClock(data) {
      params.theLocalText = data.timeText[params.LANG];
      params.theCityText = data.city[params.LANG];
      params.customOffset = data.timezone;
      params.theCity = ((data.city[params.LANG]).toLowerCase()).trim();
      params.customDST = data.dst;
      if ($(blockCity).hasClass(params.activeClass)) showTimeIn('city', params.theCity, params.customOffset, params.customDST);
    }
    // update texts for each block
    function updateAllTextBlock() {
      // update all text block
      // text.split('.')[0]);
      citytext = params.theCityText.split(',')[0];
      letterCount = citytext.replace(/\s+/g, '').length;
      if (letterCount >= 10) {
        $('#block-control').css({ left: '215px' });
        $('.block .city, .block .time').css({ 'font-size': '8px' });
      }
      if (letterCount >= 14) {
        $('#block-control').css({ left: '205px' });
        $('#clock').css({ left: '150px' });
        $('.block .city, .block .time').css({ 'font-size': '7px' });
      }
      document.getElementById('cityText').innerHTML = params.theCityText.split(',')[0];
      document.getElementById('localtext').innerHTML = params.theLocalText;
      document.getElementById('city-link').title = params.theCityText.replace('"', '&quot;');
      document.getElementById('local-link').title = params.theLocalText.replace('"', '&quot;');
      document.getElementById('city-link').href = `#${params.theCityText.replace('"', '&quot;').replace(' ', '_')}`;
      document.getElementById('local-link').href = `#${params.theLocalText.replace('"', '&quot;').replace(' ', '_')}`;
    }

    // Set times to clock
    const _cityParam = {
      tempOffset: 0,
      cityOffset: 0,
    };

    function showTimeIn(selectorID, cityname, offset, timezone, cdYear, cdMonth, cdDay, cdHour, cdMin) {
      if (params.isCountdownClock) {
        if (cityname !== '') {
          var now = new Date();
          var tempOffset = now.getTimezoneOffset();
          tempOffset += 60 * offset;
          var gettimezoneDST = getDST(new Date(), timezone);
          if (gettimezoneDST == 100) {
            // Si heure
            tempOffset += 60; // on ajoute 1h du DST
          }

          if (params.clocktimeAtEvent) {
            // si fuseau horaire local est en DST, on ajoute 1h
            var dstMinutes = now.dst() ? 60 : 0;
            rolexClockCountdown = new Date(cdYear, parseInt(cdMonth) - 1, cdDay, parseInt(cdHour), parseInt(cdMin) + dstMinutes);
            _cityParam.tempOffset = tempOffset;
            _cityParam.cityOffset = offset;
            cityTime();
            rolexClockCountdownCalc = foreignToLocal(rolexClockCountdown, offset * 100, timezone);
            setMinutesOffset(_cityParam.tempOffset); // Correct to time at event location
          } else {
            // on test la date de l'event du visiteur
            const event = foreignToLocal(new Date(cdYear, parseInt(cdMonth) - 1, cdDay, parseInt(cdHour), parseInt(cdMin)), offset * 100, timezone);
            // on retient la difference entre l'offset courant et le std offset  la date de l'event
            var dstMinutes = now.dst() && !event.dst() ? -60
              : !now.dst() && event.dst() ? -60 : 0;
            _cityParam.tempOffset = tempOffset;
            _cityParam.cityOffset = offset;
            cityTime();
            // on recupere le bon countdown
            rolexClockCountdownCalc = foreignToLocal(new Date(cdYear, parseInt(cdMonth) - 1, cdDay, parseInt(cdHour), parseInt(cdMin) + dstMinutes), offset * 100, timezone);
            // setMinutesOffset(tempOffset);
            setMinutesOffset(_cityParam.tempOffset);
          }
        }
      } else {
        // Autres...
        var now = new Date();
        var tempOffset = now.getTimezoneOffset();
        //                var today = b.getFullYear() + "-" + b.getMonth() + "-" + b.getDate() + "-" + b.getHours();
        if (params.theCityText !== '') {
          if (cityname) {
            tempOffset += 60 * offset;
            var gettimezoneDST = getDST(new Date(), timezone);
            if (gettimezoneDST == 100) {
              tempOffset += 60;
            }
            setMinutesOffset(tempOffset);
            _cityParam.tempOffset = tempOffset;
            _cityParam.cityOffset = offset;
            cityTime();
          }
        }
      }
    }

    /* yourTime text clock */
    function yourTime() {
      const a = new Date();
      a.setHours(a.getHours());
      a.setMinutes(a.getMinutes());
      a.setSeconds(a.getSeconds());
      const b = a.getSeconds();
      let c = a.getMinutes();
      let d = a.getHours();
      const e = a.getDay();
      if (params.LANG === 'en') {
        if (e == 0) {
          var f = 'Sun';
        } else if (e == 1) {
          var f = 'Mon';
        } else if (e == 2) {
          var f = 'Tue';
        } else if (e == 3) {
          var f = 'Wed';
        } else if (e == 4) {
          var f = 'Thu';
        } else if (e == 5) {
          var f = 'Fri';
        } else if (e == 6) {
          var f = 'Sat';
        }
      } else if (params.LANG === 'fr') {
        if (e == 0) {
          var f = 'Dim';
        } else if (e == 1) {
          var f = 'Lun';
        } else if (e == 2) {
          var f = 'Mar';
        } else if (e == 3) {
          var f = 'Mer';
        } else if (e == 4) {
          var f = 'Jeu';
        } else if (e == 5) {
          var f = 'Ven';
        } else if (e == 6) {
          var f = 'Sam';
        }
      }

      if (params.amPm == true) {
        var g = ' ';
        if (d >= 12) {
          g = ' PM';
        } else {
          g = ' AM';
        }
      } else {
        g = '';
      }
      if (params.time24hours == true) {
        g = '';
      } else if (d >= 13) {
        d -= 12;
      } else if (d == 0) {
        d = 12;
      }
      if (params.leadingZeros == true) {
        if (d < 10) {
          d = `0${d}`;
        }
      }
      if (params.leadingZeros == false && params.time24hours == true) {
        if (d < 10) {
          d = `0${d}`;
        }
      }
      if (c < 10) c = `0${c}`;

      if (params.showText == true) {
        if (params.showDay == true) {
          f = f;
        } else {
          f = '';
        }
        if (!params.showTime) {
          update = document.getElementById('rolexClockYourTime').innerHTML = `${f} ${d}:${c}${g}`;
        }
      }
    }

    function cityTime() {
      const cityTime = new Date();
      //            console.log(_cityParam.cityOffset , _cityParam.tempOffset)
      cityTime.setHours(cityTime.getHours());
      cityTime.setMinutes(cityTime.getMinutes() + _cityParam.tempOffset);
      cityTime.setSeconds(cityTime.getSeconds());
      const cityTime_millisecondes = cityTime.getMilliseconds();
      const cityTime_seconds = cityTime.getSeconds();
      let cityTime_minutes = cityTime.getMinutes();
      let cityTime_hours = cityTime.getHours();
      const cityTime_day = cityTime.getDay();
      if (params.LANG === 'en') {
        if (cityTime_day == 0) {
          var f = 'Sun';
        } else if (cityTime_day == 1) {
          var f = 'Mon';
        } else if (cityTime_day == 2) {
          var f = 'Tue';
        } else if (cityTime_day == 3) {
          var f = 'Wed';
        } else if (cityTime_day == 4) {
          var f = 'Thu';
        } else if (cityTime_day == 5) {
          var f = 'Fri';
        } else if (cityTime_day == 6) {
          var f = 'Sat';
        }
      } else if (params.LANG === 'fr') {
        if (cityTime_day == 0) {
          var f = 'Dim';
        } else if (cityTime_day == 1) {
          var f = 'Lun';
        } else if (cityTime_day == 2) {
          var f = 'Mar';
        } else if (cityTime_day == 3) {
          var f = 'Mer';
        } else if (cityTime_day == 4) {
          var f = 'Jeu';
        } else if (cityTime_day == 5) {
          var f = 'Ven';
        } else if (cityTime_day == 6) {
          var f = 'Sam';
        }
      }
      // console.log(cityTime_hours)
      if (params.amPm == true) {
        var g = ' ';
        if (cityTime_hours >= 12) {
          g = ' PM';
        } else {
          g = ' AM';
        }
      } else {
        g = '';
      }
      if (params.time24hours == true) {
        g = '';
      } else if (cityTime_hours >= 13) {
        cityTime_hours -= 12;
      } else if (cityTime_hours == 0) {
        cityTime_hours = 12;
      }
      if (params.leadingZeros == true) {
        if (cityTime_hours < 10) {
          cityTime_hours = `0${cityTime_hours}`;
        }
      }

      if (cityTime_minutes < 10) cityTime_minutes = `0${cityTime_minutes}`;

      if (params.showText == true) {
        if (params.showDay == true) {
          f = f;
        } else {
          f = '';
        }
      }

      if (cityTime_seconds >= 0 && cityTime_seconds < 1) {
        update = document.getElementById('rolexClockCityTime').innerHTML = `${f} ${cityTime_hours}:${cityTime_minutes}${g}`;
      } else if (checked === undefined && params.showTime == false) {
        update = document.getElementById('rolexClockCityTime').innerHTML = `${f} ${cityTime_hours}:${cityTime_minutes}${g}`;
        var checked = 1;
      }
    }

    function getSeconds() {
      const now = new Date();
      const theSeconds = now.getSeconds();
      if (theSeconds === 0) {
        requestAnimFrame(roundTime);
      }
    }
    setInterval(() => {
      getSeconds();
    }, 1000);

    function roundTime() {
      cityTime();
      yourTime();
    }

    function getOffsetBase10(offset) {
      //            console.log(typeof offset)
      const hours = parseInt(offset); // +/- N
      const decimal = offset - hours; // 0.xx
      const newDecimal = decimal / 0.60;
      //            console.log(hours, decimal, newDecimal, hours + newDecimal);
      return hours + newDecimal;
    }

    const flashMode = false;
    /**
     * Build the clock.
     * @param {object} options Options or method name
     * @returns {unresolved}
     */
    function buildClock() {
      $('body').addClass(params.LANG);

      $('.image-fallback').attr('src', `img/${params.fallback}`);

      const container = document.getElementById('rolexClockWim-container');

      if (Modernizr.retina == true) {
        //                global_watch_p["xscale"] = params.retinaXscale;
        //                global_watch_p["yscale"] = params.retinaYscale;
      }

      const blockLocal = document.getElementById('local');
      const blockCity = document.getElementById('city');

      // render view
      function changeBg(bg) {
        if (params.isCountdownClock) {
          if (bg == 'full') {
            // When Countdown is present
            // document.getElementById("rolexClockWim-container").style.background = "#fff url(''" + imgFolder + "/bg.jpg') no-repeat";
            global_watch_p.xcenter = params.globalXcenter;
            global_watch_p.ycenter = params.globalYcenter;
            //                        blockCity.style.display = "block";
            if (Modernizr.retina == true) {
              // document.getElementById("rolexClockWim-container").style.background = "transparent url('" + imgFolder + "/bg.jpg') no-repeat";
              // document.getElementById("rolexClockWim-container").style.backgroundSize = "auto 100%";
            }
          } else {
            // document.getElementById("rolexClockWim-container").style.background = "transparent url('" + imgFolder + "/bg.jpg') no-repeat";
            global_watch_p.xcenter = params.globalXcenter;
            global_watch_p.ycenter = params.globalYcenter;
            //                        blockCity.style.display = "block";
            if (Modernizr.retina == true) {
              // document.getElementById("rolexClockWim-container").style.background = "transparent url('" + imgFolder + "/bg.jpg') no-repeat";
              // document.getElementById("rolexClockWim-container").style.backgroundSize = "auto 100%";

            }
          }
        } else {
          global_watch_p.xscale = params.globalXscale;
          global_watch_p.yscale = params.globalYscale;
          global_watch_p.xcenter = params.globalXcenter;
          global_watch_p.ycenter = params.globalYcenter;
          if (bg == 'full') {
            // document.getElementById("rolexClockWim-container").style.background = "#fff url(''" + imgFolder + "/bg.jpg') no-repeat";
            //                        blockCity.style.display = "block";
            //                        blockLocal.style.display = "block";
            if (Modernizr.retina == true) {
              // document.getElementById("rolexClockWim-container").style.background = "transparent url('" + imgFolder + "/bg.jpg') no-repeat";
              // document.getElementById("rolexClockWim-container").style.backgroundSize = "auto 100%";
            }
          } else {
            // document.getElementById("rolexClockWim-container").style.background = "transparent url('" + imgFolder + "/bg.jpg') no-repeat";
            blockLocal.style.display = 'none';
            blockCity.style.display = 'none';
            if (Modernizr.retina == true) {
              // document.getElementById("rolexClockWim-container").style.background = "transparent url('" + imgFolder + "/bg.jpg') no-repeat";
              // document.getElementById("rolexClockWim-container").style.backgroundSize = "auto 100%";

            }
          }
        }
      }

      if (!params.forceFallback && !params.forceFlash && Modernizr.canvas == true && document.compatMode != 'Quirks' && oldIE != true) {
        // Canvas can be used
        $('.fallback').remove();
        $('.tracker').attr('href', params.trackingurl);

        if (!params.showText) {
          $(blockCity).hide();
          $(blockLocal).hide();
          changeBg('full');
        } else {
          const e = loadListofdates();
          //                    console.log(e);
          //                    console.log(_competition);
          const { names } = e;
          const { timezones } = e;
          const { timezone_dst } = e;
          const { timeText } = e;
          const { cdYear } = e;
          const { cdMonth } = e;
          const { cdDay } = e;
          const { cdHour } = e;
          const { cdMin } = e;
          const { ClockRacetext } = e;

          if (names.length > 0) {
            if (params.isCountdownClock) {
              rolexClockRacetext = ClockRacetext[0];
              $('#racetext').html(rolexClockRacetext);
            }
            changeBg('full');

            // Sets all string to text for each block
            if (params.isCompetitionWithCarousel) {
              // compet.
              if (names.length > 1) {
                updateCompetition();
              } else {
                // fallback
                $('.ui-loader').hide();
                $('.fallback').show();
                return;
              }
            } else {
              params.theLocalText = timeText[0];
              params.theCityText = names[0];
              params.customOffset = getOffsetBase10(timezones[0]);
              params.theCity = (names[0].toLowerCase()).trim();
              params.customDST = timezone_dst[0];
            }

            updateAllTextBlock();
          } else {
            // si aucun actif
            if (params.isCompetitionWithCarousel) {
              // compet.
              competitionBlock.style.display = 'none';
            } else if (params.isCountdownClock) {
              document.getElementById('cityText').innerHTML = '&nbsp;';
              document.getElementById('localtext').innerHTML = '&nbsp;';
              document.getElementById('city-link').title = '&nbsp;';
              document.getElementById('local-link').title = '&nbsp;';
              document.getElementById('city-link').href = '#';
              document.getElementById('local-link').href = '#';
            } else {
              changeBg();
              if (params.showTime == true) {
                document.getElementById('block-control').removeChild(blockCity);
                document.getElementById('block-control').removeChild(blockLocal);
              } else {
                document.getElementById('cityText').innerHTML = params.theCityText;
                document.getElementById('localtext').innerHTML = params.theLocalText;
                document.getElementById('city-link').title = params.theCityText.replace('"', '&quot;');
                document.getElementById('local-link').title = params.theLocalText.replace('"', '&quot;');
                document.getElementById('city-link').href = `#${params.theCityText.replace('"', '&quot;').replace(' ', '_')}`;
                document.getElementById('local-link').href = `#${params.theLocalText.replace('"', '&quot;').replace(' ', '_')}`;
              }
            }
          }

          let thenewOffset;
          let customOffset;
          let elem;

          blockLocal.onclick = function () {
            $(`.${params.blockClass}.${params.activeClass}`).removeClass(params.activeClass);
            $(this).addClass(params.activeClass);

            showCurrentTime();

            // callback
            return params.onclickYourtime();
          };
          blockCity.onclick = function () {
            $(`.${params.blockClass}.${params.activeClass}`).removeClass(params.activeClass);
            $(this).addClass(params.activeClass);

            showTimeIn('city', params.theCity, params.customOffset, params.customDST, cdYear, cdMonth, cdDay, cdHour, cdMin);

            // callback
            return params.onclickCity();
          };

          function updateShownTimeInHTMLComponentOvertime() {
            updateShownTimeInHTMLComponent();
            // timeoutID = window.setTimeout("updateShownTimeInHTMLComponentOvertime()", 100)
            requestAnimFrame(updateShownTimeInHTMLComponentOvertime());
          }

          function showCurrentTime() {
            setMinutesOffset(0);
          }

          function updateShownTimeInHTMLComponent() {
            tempString = getCurrentShownTime();
          }
          if (params.theCity != '') {
            if (params.isCountdownClock) {
              // cdYear, cdMonth, cdDay, cdHour, cdMin are Arrays! There's still a default datetime, which is always the last index.
              showTimeIn('city', params.theCity, params.customOffset, params.customDST, cdYear[0], cdMonth[0], cdDay[0], cdHour[0], cdMin[0]);
              // start countdown
              startCountdownPlugin(rolexClockLanguage, rolexClockCountdownCalc);
            } else {
              showTimeIn('city', params.theCity, params.customOffset, params.customDST);
            }
          }

          if (params.showLocalOnly) {
            showCurrentTime();
          }
          roundTime();
        }

        startWatchEngine();

        showClock();
      } else {
        // fallback
        $('.ui-loader').hide();
        $('.tracker').attr('href', params.trackingurl);
        $('.content').remove();
        $('.fallback').show();
      }
    }

    /**
     * Callback function called when countdown has expired
     * @returns {undefined}
     */
    function expiration() {
      // add class for triggering styles without CD
      $('.container').addClass('end-countdown');
    }

    /**
     * Start countdown plugin.
     * @param {string} lang The language (ex: "en")
     * @returns {undefined}
     */
    function startCountdownPlugin(lang, expirationTime) {
      if (params.LANG == 'fr') {
        $.countdown.regional.fr = {
          labels: ['Annes', 'Mois', 'Semaines', 'Jours', 'Heures', 'Mins', 'Secs'],
          labels1: ['Anne', 'Mois', 'Semaine', 'Jour', 'Heure', 'Min', 'Sec'],
          compactLabels: ['a', 'm', 's', 'j'],
          whichLabels(amount) {
            return (amount > 1 ? 0 : 1);
          },
          digits: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
          timeSeparator: ':',
          isRTL: false,
        };
        $.countdown.setDefaults($.countdown.regional.fr);
      } else if (params.LANG == 'zhs') {
        $.countdown.regional.zhs = {
          labels: ['', '', '', '', '', '', ''],
          labels1: ['', '', '', '', '', '', ''],
          compactLabels: ['', '', '', ''],
          compactLabels1: ['', '', '', ''],
          whichLabels: null,
          digits: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
          timeSeparator: ':',
          isRTL: false,
        };
        $.countdown.setDefaults($.countdown.regional.zhs);
      } else if (params.LANG == 'ja') {
        $.countdown.regional.ja = {
          labels: ['', '', '', '', '', '', ''],
          labels1: ['', '', '', '', '', '', ''],
          compactLabels: ['', '', '', ''],
          whichLabels: null,
          digits: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
          timeSeparator: ':',
          isRTL: false,
        };
        $.countdown.setDefaults($.countdown.regional.ja);
      } else if (params.LANG == 'de') {
        $.countdown.regional.de = {
          labels: ['Jahre', 'Monate', 'Wochen', 'Tage', 'Stunden', 'Min', 'Sek'],
          labels1: ['Jahr', 'Monat', 'Woche', 'Tag', 'Stunde', 'Min', 'Sek'],
          compactLabels: ['J', 'M', 'W', 'T'],
          whichLabels: null,
          digits: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
          timeSeparator: ':',
          isRTL: false,
        };
        $.countdown.setDefaults($.countdown.regional.de);
      } else if (params.LANG == 'br') {
        $.countdown.regional.br = {
          labels: ['Anos', 'Meses', 'Semanas', 'Dias', 'Horas', 'Mins', 'Segs'],
          labels1: ['Ano', 'Ms', 'Semana', 'Dia', 'Hora', 'Min', 'Seg'],
          compactLabels: ['a', 'm', 's', 'd'],
          whichLabels: null,
          digits: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
          timeSeparator: ':',
          isRTL: false,
        };
        $.countdown.setDefaults($.countdown.regional.bra);
      } else if (params.LANG == 'es') {
        $.countdown.regional.es = {
          labels: ['Aos', 'Meses', 'Semanas', 'Das', 'Horas', 'Mins', 'Segs'],
          labels1: ['Ao', 'Mes', 'Semana', 'Da', 'Hora', 'Min', 'Seg'],
          compactLabels: ['a', 'm', 's', 'd'],
          whichLabels: null,
          digits: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
          timeSeparator: ':',
          isRTL: false,
        };
        $.countdown.setDefaults($.countdown.regional.es);
      } else if (params.LANG == 'it') {
        $.countdown.regional.it = {
          labels: ['Anni', 'Mesi', 'Settimane', 'Giorni', 'Ore', 'Min', 'Sec'],
          labels1: ['Anno', 'Mese', 'Settimana', 'Giorno', 'Ora', 'Min', 'Sec'],
          compactLabels: ['a', 'm', 's', 'g'],
          whichLabels: null,
          digits: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
          timeSeparator: ':',
          isRTL: false,
        };
        $.countdown.setDefaults($.countdown.regional.it);
      } else if (params.LANG == 'ru') {
        $.countdown.regional.ru = {
          labels: ['', '', '', '', '', '', ''],
          labels1: ['', '', '', '', '', '', ''],
          labels2: ['', '', '', '', '', '', ''],
          compactLabels: ['', '', '', ''],
          compactLabels1: ['', '', '', ''],
          whichLabels(amount) {
            const units = amount % 10;
            const tens = Math.floor((amount % 100) / 10);
            return (amount === 1 ? 1 : (units >= 2 && units <= 4 && tens !== 1 ? 2
              : (units === 1 && tens !== 1 ? 1 : 0)));
          },
          digits: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
          timeSeparator: ':',
          isRTL: false,
        };
        $.countdown.setDefaults($.countdown.regional.ru);
      } else if (params.LANG == 'sv') {
        $.countdown.regional.sv = {
          labels: ['r', 'Mnader', 'Veckor', 'Dagar', 'Timmar', 'Min', 'Sek'],
          labels1: ['r', 'Mnad', 'Vecka', 'Dag', 'Timme', 'Min', 'Sek'],
          compactLabels: ['', 'M', 'V', 'D'],
          whichLabels: null,
          digits: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
          timeSeparator: ':',
          isRTL: false,
        };
        $.countdown.setDefaults($.countdown.regional.sv);
      } else if (params.LANG == 'zh-TW') {
        $.countdown.regional['zh-TW'] = {
          labels: ['', '', '', '', '', '', ''],
          labels1: ['', '', '', '', '', '', ''],
          compactLabels: ['', '', '', ''],
          compactLabels1: ['', '', '', ''],
          whichLabels: null,
          digits: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
          timeSeparator: ':',
          isRTL: false,
        };
        $.countdown.setDefaults($.countdown.regional['zh-TW']);
      } else if (params.LANG == 'ar') {
        $.countdown.regional.ar = {
          labels: ['', '', '', '', '', '', ''],
          labels1: ['', '', '', '', '', '', ''],
          compactLabels: ['', '', '', ''],
          whichLabels: null,
          digits: ['', '', '', '', '', '', '', '', '', ''],
          timeSeparator: ':',
          isRTL: true,
        };
        $.countdown.setDefaults($.countdown.regional.ar);
      } else {

      }
      // console.log(expirationTime)
      if (expirationTime !== undefined) {
        $('.container').addClass('has-countdown').removeClass('no-countdown');
        let ctdays = '';
        let cthours = '';
        let ctmins = '';
        let ctsecs = '';
        let tpl = '';
        let tpl2 = '';
        // $('.days').countdown({
        //     until: expirationTime,
        //     significant: 0,
        //     format: 'DHMS',
        //     alwaysExpire: true,
        //     layout: ctdays});
        // $('.hours').countdown({
        //     until: expirationTime,
        //     significant: 0,
        //     format: 'DHMS',
        //     alwaysExpire: true,
        //     layout: cthours});
        // $('.mins').countdown({
        //     until: expirationTime,
        //     significant: 0,
        //     format: 'DHMS',
        //     alwaysExpire: true,
        //     layout: ctmins});
        // $('.secs').countdown({
        //     until: expirationTime,
        //     significant: 0,
        //     format: 'DHMS',
        //     alwaysExpire: true,
        //     layout: ctsecs});
        if (!params.countdownNumbersOnly && $('.container').hasClass('ctdwn-twolines-horizontal')) {
          tpl = '<ul class="cd-listview">'
            + '<li class="cd-days">{dnn}</li><span></span><li class="cd-hours">{hnn}</li><span></span>'
            + '<li class="cd-minutes">{mnn}</li><span></span><li class="cd-seconds">{snn}</li></ul>';
          tpl2 = '<ul class="cd-listview">'
            + '{d<}<li class="days">{dl}</li>{d>}{h<}<li class="hours">{hl}</li>{h>}'
            + '{m<}<li class="minutes">{ml}</li>{m>}{s<}<li class="seconds">{sl}</li>{s>}</ul>';

          $('#watch_countdown_text').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl2,
          });
          $('#watch_countdown').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl,
            onExpiry: expiration,
          });
        } else if (!params.countdownNumbersOnly && $('.container').hasClass('ctdwn-oneline-horizontal')) {
          ctdays = '{d<}{dl}{d>}';
          cthours = '{d<}{hl}{d>}';
          ctmins = '{d<}{ml}{d>}';
          ctsecs = '{d<}{sl}{d>}';
          tpl = '<ul class="cd-listview">{y<}<li class="cd-years"><span></span>{yn} {yl}</li>{y>}{o<}<li class="cd-month"><span></span>{on} {ol}</li>{o>}'
            + '{d<}<li class="cd-days"><span></span>{dnn} {dl}</li>{d>}{h<}<li class="cd-hours"><span></span>{hnn} {hl}</li>{h>}'
            + '{m<}<li class="cd-minutes"><span></span>{mnn} {ml}</li>{m>}{s<}<li class="cd-seconds"><span></span>{snn} {sl}</li>{s>}</ul>';
          $('#watch_countdown').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl,
            onExpiry: expiration,
          });
        } else if (params.countdownNumbersOnly && $('.container').hasClass('ctdwn-oneline-horizontal')) {
          // console.log("here")
          ctdays = '{d<}{dl}{d>}';
          cthours = '{d<}{hl}{d>}';
          ctmins = '{d<}{ml}{d>}';
          ctsecs = '{d<}{sl}{d>}';
          tpl = '<ul class="cd-listview">{y<}<li class="cd-years"><span></span>{yn} </li>{y>}{o<}<li class="cd-months"><span></span>{on} </li>{o>}'
            + '{d<}<li class="cd-days"><span></span>{dnn} </li>{d>}{h<}<li class="cd-hours"><span></span>{hnn} </li>{h>}'
            + '{m<}<li class="cd-minutes"><span></span>{mnn} </li>{m>}{s<}<li class="cd-seconds"><span></span>{snn} </li>{s>}</ul>';
          $('#watch_countdown').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl,
            onExpiry: expiration,
          });
        } else if (!params.countdownNumbersOnly && $('.container').hasClass('ctdwn-twolinesText-horizontal')) {
          ctdays = '{d<}{dl}{d>}';
          cthours = '{d<}{hl}{d>}';
          ctmins = '{d<}{ml}{d>}';
          ctsecs = '{d<}{sl}{d>}';
          tpl = '<ul class="cd-listview">{y<}<li class="cd-years"><span></span>{yn} {yl}</li>{y>}{o<}<li class="cd-month"><span></span>{on} {ol}</li>{o>}'
            + '{d<}<li class="cd-days"><span></span>{dnn} {dl}</li>{d>}{h<}<li class="cd-hours"><span></span>{hnn} {hl}</li>{h>}'
            + '{m<}<li class="cd-minutes"><span></span>{mnn} {ml}</li>{m>}{s<}<li class="cd-seconds"><span></span>{snn} {sl}</li>{s>}</ul>';
          $('#watch_countdown').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl,
            onExpiry: expiration,
          });
          $('.has-countdown #logo').css({ display: 'block' });
        } else if (!params.countdownNumbersOnly && $('.container').hasClass('ctdwn-threelines-horizontal')) {
          // console.log("ctdwn-twolinesNew-horizontal")
          tpl = '<ul class="cd-listview">'
            + '<li class="cd-days">{dnn}</li><span></span><li class="cd-hours">{hnn}</li><span></span>'
            + '<li class="cd-minutes">{mnn}</li><span></span><li class="cd-seconds">{snn}</li></ul>';
          tpl2 = '<ul class="cd-listview">'
            + '{d<}<li class="days">{dl}</li>{d>}{h<}<li class="hours">{hl}</li>{h>}'
            + '{m<}<li class="minutes">{ml}</li>{m>}{s<}<li class="seconds">{sl}</li>{s>}</ul>';
          $('#watch_countdown').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl,
            onExpiry: expiration,
          });
          $('#watch_countdown_text').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl2,
          });
        } else if (!params.countdownNumbersOnly && $('.container').hasClass('ctdwn-twolinesNew-horizontal')) {
          // console.log("ctdwn-twolinesNew-horizontal")
          tpl = '<ul class="cd-listview">'
            + '<li class="cd-days">{dnn}</li><span>:</span><li class="cd-hours">{hnn}</li><span>:</span>'
            + '<li class="cd-minutes">{mnn}</li><span>:</span><li class="cd-seconds">{snn}</li></ul>';
          tpl2 = '<ul class="cd-listview">'
            + '{d<}<li class="days">{dl}</li>{d>}{h<}<li class="hours">{hl}</li>{h>}'
            + '{m<}<li class="minutes">{ml}</li>{m>}{s<}<li class="seconds">{sl}</li>{s>}</ul>';
          $('#watch_countdown').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl,
            onExpiry: expiration,
          });
          $('#watch_countdown_text').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl2,
          });
        } else if (!params.countdownNumbersOnly && $('.container').hasClass('ctdwn-threelinesNew-horizontal')) {
          // console.log("ctdwn-twolinesNew-horizontal")
          tpl = '<ul class="cd-listview">'
            + '<li class="cd-days">{dnn}</li><span>:</span><li class="cd-hours">{hnn}</li><span>:</span>'
            + '<li class="cd-minutes">{mnn}</li><span>:</span><li class="cd-seconds">{snn}</li></ul>';
          tpl2 = '<ul class="cd-listview">'
            + '{d<}<li class="days">{dl}</li>{d>}{h<}<li class="hours">{hl}</li>{h>}'
            + '{m<}<li class="minutes">{ml}</li>{m>}{s<}<li class="seconds">{sl}</li>{s>}</ul>';
          $('#watch_countdown').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl,
            onExpiry: expiration,
          });
          $('#watch_countdown_text').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl2,
          });
        } else if (params.countdownNumbersOnly && $('.container').hasClass('ctdwn-twolinesNew-horizontal')) {
          // console.log("ctdwn-twolinesNew-horizontal")
          tpl = '<ul class="cd-listview">{y<}<li class="cd-years"><span></span>{yn} </li>{y>}{o<}<li class="cd-months"><span></span>{on} </li>{o>}'
            + '{d<}<li class="cd-days"><span></span>{dnn} </li>{d>}{h<}<li class="cd-hours"><span></span>{hnn} </li>{h>}'
            + '{m<}<li class="cd-minutes"><span></span>{mnn} </li>{m>}{s<}<li class="cd-seconds"><span></span>{snn} </li>{s>}</ul>';
          $('#watch_countdown').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl,
            onExpiry: expiration,
          });
        } else {
          tpl = '<ul class="cd-listview">{y<}<li class="cd-years"><span></span>{yn} {yl}</li>{y>}{o<}<li class="cd-month"><span></span>{on} {ol}</li>{o>}'
            + '{d<}<li class="cd-days"><span></span>{dnn} {dl}</li>{d>}{h<}<li class="cd-hours"><span></span>{hnn} {hl}</li>{h>}'
            + '{m<}<li class="cd-minutes"><span></span>{mnn} {ml}</li>{m>}{s<}<li class="cd-seconds"><span></span>{snn} {sl}</li>{s>}</ul>';
          $('#watch_countdown').countdown({
            until: expirationTime,
            significant: 0,
            format: 'DHMS',
            alwaysExpire: true,
            layout: tpl,
            onExpiry: expiration,
          });
        }
      }
    }
    // build the clock
    buildClock(params);
  };
}(jQuery));

/**
 * Get Standard Timezone Offset
 * @returns {integer} Returns offset in minutes
 */
Date.prototype.stdTimezoneOffset = function () {
  const jan = new Date(this.getFullYear(), 0, 1);
  const jul = new Date(this.getFullYear(), 6, 1);
  return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
};
/**
   * Tells whether it is in Daylight Saving Time (Summer Time)
   * @returns {Boolean} DST or not
   */
Date.prototype.dst = function () {
  return this.getTimezoneOffset() < this.stdTimezoneOffset();
};

'use strict';
/*

NOTE: daylight saving time is *not* observed in the following countries (by region):
* Europe
  Iceland

* North America and the Caribbean
  Cayman Islands, Jamaica, Puerto Rico, Trinidad and Tobago

* South America
  Colombia, Guyana, Peru, Venezuela

* Africa
  no countries observe DST, *except* for Canary Islands, Egypt, Namibia, Tunisia

* Asia
  Mongolia, China, Hong Kong, Macau, Korean Peninsula, Japan, Central Asian states,
  Nepal, Bhutan, Afghanistan, Iran, Kazakhstan, Kyrgyzstan, Pakistan, India, Bangladesh,
  Reof China (Taiwan), Myanmar, Thailand, Laos, Vietnam, Philippines, Cambodia,
  Malaysia, Brunei, Singapore, Indonesia, Timor Leste, Papua New Guinea,
  Saudi Arabia, Bahrain, Qatar

* Oceania
  no countries observe DST, *except* for Australia, New Zealand
  for Australia, see: http://www.bcl.com.au/times-daylight-saving.htm
  - New South Wales (Sydney), Victoria (Melbourne), South Australia (Adelaide), Tasmania (Hobart), Australian Capital Territory (Canberra)
    first Sunday in October through first Sunday in April
  - Western Australia (Perth) commenced a 3 year trial on 3rd December 2006, to be followed by a referendum in 2009
    last Sunday in October through last Sunday in March
  - Queensland (Brisbane): Eastern Standard Time all year
  - Northern Territory do not change their clocks

NOTE: other areas where daylight saving time is not observed
      are listed under each DST type within getDST()
'use strict';
NOTE: ONLY GOOD FOR 2008 because too complex to make general calculation:
* Israel
  start: last Friday before April 2
  end: the Sunday between Rosh Hashanah and Yom Kippur

*/

// enum for weekdays used in firstWeekday() and lastWeekday()
const SUN = 0;
const MON = 1;
const TUE = 2;
const WED = 3;
const THU = 4;
const FRI = 5;
const SAT = 6;

// enum for countries/zones getDST()
// Europe, Greenland, Russia, Canary Islands, Tunisia
const EUROPE = 10;

// USA, Canada
const USA = 20;
// Mexico uses old USA rules
const MEXICO = 21;
const GUATEMALA = 22;
const CUBA = 23;

const BRAZIL = 30;
const CHILE = 31;
const PARAGUAY = 32;
const URUGUAY = 33;
const ARGENTINA = 34;

const EGYPT = 40;
const NAMIBIA = 41;
const MOROCCO = 42;

const JORDAN = 50;
const SYRIA = 51;
const IRAQ = 52;
const ISRAEL = 53;
const PAKISTAN = 54;

// Australia: New South Wales (Sydney), Victoria (Melbourne), South Australia (Adelaide), Tasmania (Hobart),
//   Australian Capital Territory (Canberra)
const AUSTRALIA = 60;
// Australia: Western Australia (Perth)
const AUSTRALIA_WESTERN = 61;
const NEW_ZEALAND = 62;

// prevent instantiation

function TimezoneUtil() {}

// NOTE: for all functions, "dst_type" is in base 10:
//   +100 = GMT+0100 = UTC +1 hour, 0 minutes
//   -1000 = GMT-1000 = UTC -10 hours, 0 minutes
//   +530 = GMT+0530 = UTC +5 hours, 30 minutes
// converts a "dst_type" number to its components: hours, minutes, and combined time in minutes
// ex: +100 = hour: 1, minute: 0, minutes: 60
// ex: -430 = hour: -4, minute: -30, minutes: -270

function dstToComponents(dst_type) {
  let dst_obj = {
    hour: 0,
    minute: 0,
    minutes: 0,
  };

  if (dst_type !== null) {
    let dst_hour = Math.floor(Math.abs(dst_type) / 100);
    if (dst_type < 0) {
      dst_hour = -dst_hour;
    }
    const dst_minute = dst_type % 100;
    const dst_minutes = dst_hour * 60 + dst_minute;

    dst_obj = {
      hour: dst_hour,
      minute: dst_minute,
      minutes: dst_minutes,
    };
  }

  return dst_obj;
}

// returns the date (1..31) for the first weekday (0..6)
// of the month (and year) given by reference date
function firstWeekday(weekday, reference_date) {
  let first_weekday = null;

  if ((reference_date !== null) && (weekday !== null) && (weekday >= 0)) {
    weekday %= 7;

    // create a Date for the first day of current month
    const test_date = new Date(reference_date.getFullYear(), reference_date.getMonth(), 1);

    let test_weekday = test_date.getDay();
    first_weekday = test_date.getDate();

    if (test_weekday !== weekday) {
      if (test_weekday > weekday) {
        test_weekday -= 7;
      }
      first_weekday -= (test_weekday - weekday);
    }
  }

  return first_weekday;
}

// returns the date (1..31) for the last weekday (0..6)
// of the month (and year, important for leap days) given by reference date
function lastWeekday(weekday, reference_date) {
  let last_weekday = null;

  if ((reference_date !== null) && (weekday !== null) && (weekday >= 0)) {
    weekday %= 7;

    // create a Date for the last day of current month
    // (next month minus one day)
    const test_date = new Date(reference_date.getFullYear(), reference_date.getMonth() + 1, 0);

    let test_weekday = test_date.getDay();
    last_weekday = test_date.getDate();

    if (test_weekday !== weekday) {
      if (test_weekday < weekday) {
        test_weekday += 7;
      }
      last_weekday -= (test_weekday - weekday);
    }
  }

  return last_weekday;
}

// returns Daylight Savings Time offset (summer time)
// 0 if not in DST
// +0100 if in DST

function getDST(reference_date, dst_type) {
  let dst = 0;
  const month = reference_date.getUTCMonth() + 1;
  const mday = reference_date.getUTCDate();
  switch (dst_type) {
    case 'EUROPE':
      // Europe, Greenland, Russia, Canary Islands, Tunisia
      // start: last Sunday in March
      // end: last Sunday in October
      // time: 1 am (01:00) Greenwich Mean Time (GMT) (ignored)
      // Russia time: 2 am local time (ignored)
      if ((month > 3) && (month < 10)) {
        dst = +100;
      } else if ((month === 3) && (mday >= lastWeekday(SUN, reference_date))) {
        dst = +100;
      } else if ((month === 10) && (mday < lastWeekday(SUN, reference_date))) {
        dst = +100;
      }

      break;
    case 'USA':
      // USA, Canada
      // start: second Sunday in March at 02:00:00
      // end: first Sunday in November at 02:00:00
      // * not observed in U.S.: Arizona, Hawaii
      // * not observed in U.S territories: American Samoa, Guam, Puerto Rico, the U.S. Virgin Islands
      // * not observed in Canada: Saskatchewan, northeastern British Columbia and Southampton Island in Nunavut
      if ((month > 3) && (month < 11)) {
        dst = +100;
      } else if ((month === 3) && (mday >= firstWeekday(SUN, reference_date) + 7)) {
        dst = +100;
      } else if ((month === 11) && (mday < firstWeekday(SUN, reference_date))) {
        dst = +100;
      }

      break;
    case 'MEXICO':
      // Mexico (old USA rules)
      // start: first Sunday in April at 02:00:00
      // end: last Sunday in October at 02:00:00
      // * not observed in: Sonora
      if ((month > 4) && (month < 10)) {
        dst = +100;
      } else if ((month === 4) && (mday >= firstWeekday(SUN, reference_date))) {
        dst = +100;
      } else if ((month === 10) && (mday < lastWeekday(SUN, reference_date))) {
        dst = +100;
      }

      break;
    case 'GUATEMALA':
      // Guatemala
      // no DST in 2007, 2008, 2010
      break;
    case 'CUBA':
      // Cuba
      // start: second Sunday in March
      // end: last Sunday in October
      // time: 1 am local time (ignored)
      if ((month > 3) && (month < 10)) {
        dst = +100;
      } else if ((month === 3) && (mday >= firstWeekday(SUN, reference_date) + 7)) {
        dst = +100;
      } else if ((month === 10) && (mday < lastWeekday(SUN, reference_date))) {
        dst = +100;
      }

      break;
    case 'BRAZIL':
      // Brazil
      // NOTE: starting and ending dates are variable - this is just an approximation!
      // start: third Saturday in October at 23:59:59
      // end: third Saturday in February at 23:59:59
      // * not observed in: Acre, Alagoas, Amap, Amazonas, Bahia, Cear, Maranho, Par, Paraba, Pernambuco,
      //   Piau, Rio Grande do Norte, Rondnia, Roraima, Sergipe, Tocantins
      if ((month > 10) || (month < 2)) {
        dst = +100;
      } else if ((month === 10) && (mday >= firstWeekday(SUN, reference_date) + 14)) {
        dst = +100;
      } else if ((month === 2) && (mday < firstWeekday(SUN, reference_date) + 14)) {
        dst = +100;
      }

      break;
    case 'CHILE':
      // Chile
      // NOTE: in specific years the starting and ending dates have been modified for political or climatic reasons
      // start: second Sunday in October
      // end: first Sunday in April
      // time: midnight local time
      if ((month > 10) || (month < 4)) {
        dst = +100;
      } else if ((month === 10) && (mday >= firstWeekday(SUN, reference_date) + 7)) {
        dst = +100;
      } else if ((month === 4) && (mday < firstWeekday(SUN, reference_date))) {
        dst = +100;
      }

      break;
    case 'PARAGUAY':
      // Paraguay
      // start: first Sunday in October at 00:00:00
      // end: second Sunday in April at 00:00:00
      if ((month > 10) || (month < 4)) {
        dst = +100;
      } else if ((month === 10) && (mday >= firstWeekday(SUN, reference_date))) {
        dst = +100;
      } else if ((month === 4) && (mday < firstWeekday(SUN, reference_date) + 7)) {
        dst = +100;
      }

      break;
    case 'URUGUAY':
      // Uruguay
      // start: first Sunday in October
      // end: second Sunday in March
      if ((month > 10) || (month < 3)) {
        dst = +100;
      } else if ((month === 10) && (mday >= firstWeekday(SUN, reference_date))) {
        dst = +100;
      } else if ((month === 3) && (mday < firstWeekday(SUN, reference_date) + 7)) {
        dst = +100;
      }

      break;
    case 'ARGENTINA':
      // Argentina
      // no DST in 2010
      break;
    case 'EGYPT':
      // Egypt
      // start: last Friday in April at 00:00:00
      // end: first Friday in August at 00:00:00
      // NOTE! STARTING 2011... end: last Friday in September at 00:00:00
      if ((month > 4) && (month < 8)) {
        dst = +100;
      } else if ((month === 4) && (mday >= lastWeekday(FRI, reference_date))) {
        dst = +100;
      } else if ((month === 8) && (mday < firstWeekday(FRI, reference_date))) {
        dst = +100;
      }

      break;
    case 'NAMIBIA':
      // Namibia
      // start: first Sunday in September
      // end: first Sunday in April
      if ((month > 9) || (month < 4)) {
        dst = +100;
      } else if ((month === 9) && (mday >= firstWeekday(SUN, reference_date))) {
        dst = +100;
      } else if ((month === 4) && (mday < firstWeekday(SUN, reference_date))) {
        dst = +100;
      }

      break;
    case 'MOROCCO':
      // no DST in 2009, 2010
      break;
    case 'JORDAN':
      // Jordan
      // start: last Friday in March at 00:00:00
      // end: last Friday in October at 01:00:00
      if ((month > 3) && (month < 10)) {
        dst = +100;
      } else if ((month === 3) && (mday >= lastWeekday(FRI, reference_date))) {
        dst = +100;
      } else if ((month === 10) && (mday < lastWeekday(FRI, reference_date))) {
        dst = +100;
      }

      break;
    case 'SYRIA':
      // Syria
      // start: first Friday in April at 00:00:00
      // end: last Friday in October at 00:00:00
      if ((month > 4) && (month < 10)) {
        dst = +100;
      } else if ((month === 4) && (mday >= firstWeekday(FRI, reference_date))) {
        dst = +100;
      } else if ((month === 10) && (mday < lastWeekday(FRI, reference_date))) {
        dst = +100;
      }

      break;
    case 'IRAQ':
      // Iraq
      // no DST in 2010
      break;
    case 'ISRAEL':
      // Israel
      // NOTE: ONLY GOOD FOR 2010 because too complex to make general calculation
      // start: last Friday before April 2 at 02:00:00
      // end: the Sunday between Rosh Hashanah and Yom Kippur at 02:00:00
      // 2010: starts 26 March, ends 12 September
      // 2011: starts 1 April, ends 2 October
      // 2012: starts 30 March, ends 23 September
      // 2013: starts 29 March, ends 8 September
      // 2014: starts 28 March, ends 28 September
      // 2015: starts 27 March, ends 20 September
      switch (reference_date.getUTCFullYear()) {
        // 2010: starts 26 March, ends 12 September
        case 2010:
          if ((month > 3) && (month < 9)) {
            dst = +100;
          } else if ((month === 3) && (mday >= 26)) {
            dst = +100;
          } else if ((month === 9) && (mday < 12)) {
            dst = +100;
          }
          break;
          // 2011: starts 1 April, ends 2 October
        case 2011:
          if ((month > 4) && (month < 10)) {
            dst = +100;
          } else if ((month === 4) && (mday >= 1)) {
            dst = +100;
          } else if ((month === 10) && (mday < 2)) {
            dst = +100;
          }
          break;
          // 2012: starts 30 March, ends 23 September
        case 2012:
          if ((month > 3) && (month < 9)) {
            dst = +100;
          } else if ((month === 3) && (mday >= 30)) {
            dst = +100;
          } else if ((month === 9) && (mday < 23)) {
            dst = +100;
          }
          break;
          // 2013: starts 29 March, ends 8 September
        case 2013:
          if ((month > 3) && (month < 9)) {
            dst = +100;
          } else if ((month === 3) && (mday >= 29)) {
            dst = +100;
          } else if ((month === 9) && (mday < 8)) {
            dst = +100;
          }
          break;
          // 2014: starts 28 March, ends 28 September
        case 2014:
          if ((month > 3) && (month < 9)) {
            dst = +100;
          } else if ((month === 3) && (mday >= 28)) {
            dst = +100;
          } else if ((month === 9) && (mday < 28)) {
            dst = +100;
          }
          break;
          // 2015: starts 27 March, ends 20 September
        case 2015:
          if ((month > 3) && (month < 9)) {
            dst = +100;
          } else if ((month === 3) && (mday >= 27)) {
            dst = +100;
          } else if ((month === 9) && (mday < 20)) {
            dst = +100;
          }
          break;
          // less-than-ideal fallback: starts last Friday in March, ends 20 September
        default:
          if ((month > 3) && (month < 9)) {
            dst = +100;
          } else if ((month === 3) && (mday >= lastWeekday(FRI, reference_date))) {
            dst = +100;
          } else if ((month === 9) && (mday < 20)) {
            dst = +100;
          }
          break;
      }

      break;
    case 'PAKISTAN':
      // start: third Thursday in April at 00:00:00
      // end: first Monday in November at 00:00:00
      if ((month > 4) && (month < 11)) {
        dst = +100;
      } else if ((month === 4) && (mday >= firstWeekday(THU, reference_date) + 14)) {
        dst = +100;
      } else if ((month === 11) && (mday < firstWeekday(MON, reference_date))) {
        dst = +100;
      }

      break;
    case 'AUSTRALIA':
      // Australia: New South Wales (Sydney), Victoria (Melbourne), South Australia (Adelaide), Tasmania (Hobart), Australian Capital Territory (Canberra)
      // start: first Sunday in October at 02:00:00
      // end: first Sunday in April at 03:00:00
      // * not observed in: Northern Territory, Queensland
      if ((month > 10) || (month < 4)) {
        dst = +100;
      } else if ((month === 10) && (mday >= firstWeekday(SUN, reference_date))) {
        dst = +100;
      } else if ((month === 4) && (mday < firstWeekday(SUN, reference_date))) {
        dst = +100;
      }

      break;
    case 'AUSTRALIA_WESTERN':
      // Australia: Western Australia (Perth)
      // no DST in 2010 (DST was only used for a trial period during the summers of 2006, 2007, 2008, 2009)
      break;
    case 'NEW_ZEALAND':
      // New Zealand
      // start: last Sunday in September
      // end: first Sunday in April
      // time: 2 am local time (ignored)
      if ((month > 9) || (month < 4)) {
        dst = +100;
      } else if ((month === 9) && (mday >= lastWeekday(SUN, reference_date))) {
        dst = +100;
      } else if ((month === 4) && (mday < firstWeekday(SUN, reference_date))) {
        dst = +100;
      }

      break;
  }

  return dst;
}
// converts a Date object from one based in a given timezone to the local time
// (pass zone_offset + dst_type that the date to convert uses)
// ex: we're in Paris, 01 January 14:00 & -600 & USA => 21:00
// ex: we're in Chicago, 01 January 14:00 & +100 & EUROPE => 07:00

function foreignToLocal(base_date, zone_offset, dst_type) {
  const ofs_obj = dstToComponents(zone_offset + getDST(base_date, dst_type));
  // console.log(new Date(base_date.getTime() - ((base_date.getTimezoneOffset() + ofs_obj.minutes) * 60000)))
  return new Date(base_date.getTime() - ((base_date.getTimezoneOffset() + ofs_obj.minutes) * 60000));
}

// converts a Date object from the local time to one based in a given timezone
// (pass zone_offset + dst_type for the region to convert the date to)
// ex: we're in Paris, 01 January 14:00 & -600 & USA => 07:00
// ex: we're in Chicago, 01 January 14:00 & +100 & EUROPE => 21:00

function localToForeign(base_date, zone_offset, dst_type) {
  const ofs_obj = dstToComponents(zone_offset + getDST(base_date, dst_type));

  return new Date(base_date.getTime() + ((base_date.getTimezoneOffset() + ofs_obj.minutes) * 60000));
}

/*
 * Copyright (c) 2019 Omnigon Communications, LLC. All rights reserved.
 *
 * This software is the confidential and proprietary information of Omnigon Communications, LLC
 * ("Confidential Information"). You shall not disclose such Confidential Information and shall access and use it only
 * in accordance with the terms of the license agreement you entered into with Omnigon Communications, LLC, its
 * subsidiaries, affiliates or authorized licensee. Unless required by applicable law or agreed to in writing, this
 * Confidential Information is provided on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the license agreement for the specific language governing permissions and limitations.
 */

// ******* Configuration ********** //
// language leave blank for english
var rolexClockLanguage = 'en'; // en,fr,zhs,ja,de,ru,es

/*
 * Available dimensions.
 * How to: comment unused ones.
 */
const rolexClockScale = {
  50: { width: 100, height: 100, scale: 0.55 },
  60: { width: 120, height: 120, scale: 0.65 },
  65: { width: 130, height: 130, scale: 0.70 },
  70: { width: 140, height: 140, scale: 0.75 },
  75: { width: 150, height: 150, scale: 0.80 },
  80: { width: 160, height: 160, scale: 0.85 },
  90: { width: 180, height: 180, scale: 0.95 },
  100: { width: 200, height: 200, scale: 1.05 },
  110: { width: 220, height: 220, scale: 1.15 },
  120: { width: 240, height: 240, scale: 1.25 },
  130: { width: 260, height: 260, scale: 1.35 },
  140: { width: 280, height: 280, scale: 1.45 },
  150: { width: 300, height: 300, scale: 1.55 },
  300: { width: 600, height: 600, scale: 3 },
};
const dim = rolexClockScale[80];

/*
 * Available assets
 * How to use: comment unused ones.
 */
const rolexAssets = {
  green: './rolex/img/hands/green/',
  white: './rolex/img/hands/white/',
  silver: './rolex/img/hands/silver/',
};
const handsFolder = rolexAssets.white;

const tokenize = function (str, delimiter) {
  delimiter = delimiter || '&';
  const pairs = str.split(delimiter);
  const tokens = {};
  for (let i = 0, ii = pairs.length; i < ii; i++) {
    const pair = pairs[i].split('=');
    tokens[pair[0]] = pair[1];
  }
  return tokens;
};

const urlParams = tokenize(window.document.location.search.slice(1));
const citiesParamName = urlParams.cities;

const clockSettings = {
  LANG: rolexClockLanguage, // Language
  contentWidth: 320, // px Width of the content
  contentHeight: 90, // px Height of the content
  clockWidth: dim.width,
  /* width of the clock to be set on top the html file */
  clockHeight: dim.height,
  /* height of the clock to be set on top the html file */
  flashname: '',
  /* set the flash name (place the file in the img folder) */
  fallback: '',
  /* set the fallback image name (place the file in the img folder) */
  trackingurl: 'https://www.rolex.com/?cmpid=dsp_Clock_pgatour.com_2019_rlx19017065',
  /* set the tracking url */
  leadingZeros: false,
  amPm: true,
  /* display AM/PM text */
  time24hours: false,
  /* display time in 24 hours format */
  showText: true,
  /* display texts and time */
  showTime: false,
  /* display time without city name, 'Your Time' text */
  showDay: false,
  /* show the weekday in text */
  globalXcenter: (dim.width / 2) - 0.75,
  globalYcenter: (dim.height / 2) + 2.5,
  globalXscale: dim.scale,
  globalYscale: dim.scale,
  handsFolder, // hands folder
  clocktimeAtEvent: false, // Tells whether we display the time at the event location, defined in listofdates.js or not
  countdownNumbersOnly: false, // Display only numbers in count
  showDefaultCity: false, // Show the default city if no configurable city is currently active
  dateList: window.parent[citiesParamName], // List of date
  isCountdownClock: false, // Whether it is a countdown
  blockcontrollerVisible: true,
  showLocalOnly: false,
  isExported: false,
};

(function ($, document) {
  $(document).ready(() => {
    $('.container').rolexClock(clockSettings);
  });
}(jQuery, document));
